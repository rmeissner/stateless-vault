{"version":3,"sources":["../../../src/utils/signatures.ts","../../../src/utils/proof.ts","../../src/index.ts","utils/config.ts","components/WalletInfo.tsx","logic/ethereumRepository.ts","logic/vaultRepository.ts","components/vault/VaultTransactions.tsx","components/vault/VaultSettings.tsx","components/vault/VaultHome.tsx","assets/icons/yacate-logo.svg","components/onboarding/Welcome.tsx","utils/general.ts","components/App.tsx","styles/global.ts","Root.tsx","serviceWorkerRegistraction.ts","index.tsx","../../../src/utils/ipfs.ts"],"names":["prepareEthSignSignatureForSafe","signature","replace","right","e","config","rpcUrl","process","REACT_APP_RPC_URL","chainName","1","4","100","parseInt","REACT_APP_CHAIN_ID","AccountInfo","address","className","textColor","hash","textSize","showCopyBtn","showIdenticon","showEtherscanBtn","shortenHash","network","localProvider","providers","JsonRpcProvider","url","SELECTED_VAULT_STORAGE_KEY","loadLastSelectedVault","a","store","localStorage","getItem","undefined","holder","JSON","parse","version","Error","value","getVaultInstance","utils","isAddress","Vault","styles","createStyles","list","item","display","withStyles","vault","classes","console","log","React","transactions","setTransactions","loadTransactions","error","listItems","map","tx","index","action","ListItem","Box","length","textOverflow","overflow","txHash","success","nonce","toString","ethereumHash","List","content","justifyContent","maxWidth","configuration","setConfiguration","loadConfig","threshold","signers","signer","WalletInfo","implementation","toolbar","paddingBottom","flex","navigation","height","position","bottom","width","VaultHomeContainer","styled","main","match","useRouteMatch","active","setActive","history","useHistory","vaultAddress","useParams","instance","push","loadActive","AppBar","Toolbar","Container","path","to","BottomNavigation","onChange","_","newValue","showLabels","BottomNavigationAction","label","icon","Timeline","Settings","OnboardingContainer","SHeading","h1","Welcome","src","AppLogo","alt","undefinedOnError","func","App","loadSelected","useCallback","selectedVault","useEffect","onboardingDone","GlobalStyles","createGlobalStyle","normalize","avertaFont","avertaBoldFont","Root","StrictMode","theme","Boolean","window","location","hostname","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","chunk"],"mappings":"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","file":"static/js/main.bdd9ed29.chunk.js","sourcesContent":["export const prepareEthSignSignatureForSafe = (signature) => {\n    return signature.replace(/00$/, \"1f\").replace(/1b$/, \"1f\").replace(/01$/, \"20\").replace(/1c$/, \"20\");\n};\n//# sourceMappingURL=signatures.js.map","import { constants, utils } from 'ethers';\nexport const buildProof = async (txSigners, allSigners) => {\n    const ownersCopy = [...allSigners];\n    const indeces = txSigners.map(signer => {\n        const i = ownersCopy.indexOf(signer);\n        ownersCopy[i] = null;\n        return i;\n    });\n    const hashes = [];\n    const nodes = allSigners.map(signer => txSigners.indexOf(signer) < 0 ? utils.solidityKeccak256([\"uint256\"], [signer]) : \"0x0\");\n    let nodesCount = nodes.length;\n    while (nodesCount > 1) {\n        for (let i = 0; i < nodesCount; i += 2) {\n            let left = nodes[i];\n            let right;\n            if (i + 1 < nodesCount) {\n                right = nodes[i + 1];\n            }\n            else {\n                right = utils.solidityKeccak256([\"uint256\"], [\"0x0\"]);\n            }\n            if (left == \"0x0\" && right == \"0x0\") {\n                nodes[Math.floor(i / 2)] = \"0x0\";\n                continue;\n            }\n            if (left == \"0x0\") {\n                hashes.push(right);\n                nodes[Math.floor(i / 2)] = \"0x0\";\n                continue;\n            }\n            if (right == \"0x0\") {\n                hashes.push(left);\n                nodes[Math.floor(i / 2)] = \"0x0\";\n                continue;\n            }\n            nodes[Math.floor(i / 2)] = utils.solidityKeccak256([\"bytes32\", \"bytes32\"], [left, right]);\n        }\n        nodesCount = Math.ceil(nodesCount / 2);\n    }\n    return { indeces, hashes };\n};\nexport const buildValidationData = async (vaultConfig, signatures, signers) => {\n    const { indeces, hashes } = await buildProof(signers, vaultConfig.signers);\n    const validationData = utils.defaultAbiCoder.encode([\"uint256\", \"uint256\", \"address\", \"address\", \"uint256[]\", \"bytes32[]\", \"bytes\"], [vaultConfig.threshold, vaultConfig.signers.length, constants.AddressZero, constants.AddressZero, indeces, hashes, signatures]);\n    return validationData;\n};\n//# sourceMappingURL=proof.js.map","import FactoryAbi from './abis/Factory.json';\nimport EIP712Domain from \"eth-typed-data\";\nimport { Contract, constants, utils, BigNumber } from 'ethers';\nimport { buildValidationData } from './utils/proof';\nimport { pullWithKeccak } from './utils/ipfs';\nimport { prepareEthSignSignatureForSafe } from './utils/signatures';\nimport StatelessVault from '@rmeissner/stateless-vault-contracts/build/contracts/StatelessVault.json';\nimport Initializor from '@rmeissner/stateless-vault-contracts/build/contracts/Initializor.json';\nimport RelayedFactory from '@rmeissner/stateless-vault-contracts/build/contracts/ProxyFactoryWithInitializor.json';\nexport class BaseFactory {\n    constructor() {\n        this.vaultInterface = Contract.getInterface(StatelessVault.abi);\n    }\n    async creationData(vaultSetup) {\n        return this.vaultInterface.encodeFunctionData(\"setup(address[],uint256,address,address,address)\", [vaultSetup.signers, vaultSetup.threshold, constants.AddressZero, constants.AddressZero, constants.AddressZero]);\n    }\n}\nexport class LocalVaultFactory extends BaseFactory {\n    constructor(config) {\n        super();\n        this.config = config;\n        this.factoryInstance = new Contract(config.factoryAddress, FactoryAbi, config.signer);\n    }\n    async calculateAddress(initializer, saltNonce) {\n        const initializerHash = utils.solidityKeccak256([\"bytes\"], [initializer]);\n        const salt = utils.solidityKeccak256(['bytes32', 'uint256'], [initializerHash, saltNonce]);\n        const proxyCreationCode = await this.factoryInstance.proxyCreationCode();\n        const proxyDeploymentCode = utils.solidityPack(['bytes', 'uint256'], [proxyCreationCode, this.config.vaultImplementationAddress]);\n        const proxyDeploymentCodeHash = utils.solidityKeccak256([\"bytes\"], [proxyDeploymentCode]);\n        const address = utils.solidityKeccak256(['bytes1', 'address', 'bytes32', 'bytes32'], [\"0xFF\", this.config.factoryAddress, salt, proxyDeploymentCodeHash]);\n        return \"0x\" + address.slice(-40);\n    }\n    async create(vaultSetup, saltString) {\n        const initializer = await this.creationData(vaultSetup);\n        const saltNonce = utils.keccak256(Buffer.from(saltString || `${new Date()}`));\n        try {\n            const tx = await this.factoryInstance.createProxyWithNonce(this.config.vaultImplementationAddress, initializer, saltNonce);\n            await tx.wait();\n            console.log(tx);\n        }\n        catch (e) { }\n        const address = await this.calculateAddress(initializer, saltNonce);\n        return new Vault(this.config.signer.provider, address);\n    }\n}\nexport class RelayedVaultFactory extends BaseFactory {\n    constructor(config) {\n        super();\n        this.initializorInterface = Contract.getInterface(Initializor.abi);\n        this.config = config;\n        this.relayFactoryInstance = new Contract(config.relayFactoryAddress, RelayedFactory.abi, config.provider);\n        this.factoryInstance = new Contract(config.factoryAddress, FactoryAbi, config.provider);\n    }\n    async calculateAddress(saltNonce, validators, intializor) {\n        const proxyCreationData = this.initializorInterface.encodeFunctionData(\"setValidators\", [validators]);\n        const intializorAddress = intializor || await this.relayFactoryInstance.callStatic.initializor();\n        const initializerHash = utils.solidityKeccak256([\"bytes\"], [proxyCreationData]);\n        const salt = utils.solidityKeccak256(['bytes32', 'uint256'], [initializerHash, saltNonce]);\n        const proxyCreationCode = await this.factoryInstance.proxyCreationCode();\n        const proxyDeploymentCode = utils.solidityPack(['bytes', 'uint256'], [proxyCreationCode, intializorAddress]);\n        const proxyDeploymentCodeHash = utils.solidityKeccak256([\"bytes\"], [proxyDeploymentCode]);\n        const address = utils.solidityKeccak256(['bytes1', 'address', 'bytes32', 'bytes32'], [\"0xFF\", this.config.factoryAddress, salt, proxyDeploymentCodeHash]);\n        return \"0x\" + address.slice(-40);\n    }\n    saltNonce(saltString) {\n        return utils.keccak256(Buffer.from(saltString || `${new Date()}`));\n    }\n    async relayData(validator, setupTransaction, saltNonce) {\n        const intializorAddress = await this.relayFactoryInstance.callStatic.initializor();\n        const initializor = new Contract(intializorAddress, this.initializorInterface, this.config.provider);\n        const validatorAddress = await validator.getAddress();\n        const vaultAddress = await this.calculateAddress(saltNonce, [validatorAddress], intializorAddress);\n        const setupHash = await initializor.callStatic.generateSetupHashForAddress(vaultAddress, this.config.vaultImplementationAddress, setupTransaction.to, setupTransaction.value, setupTransaction.data, setupTransaction.operation, utils.solidityPack([\"address[]\"], [[validatorAddress]]));\n        const signatures = prepareEthSignSignatureForSafe(await validator.signMessage(utils.arrayify(setupHash)));\n        return {\n            implementation: this.config.vaultImplementationAddress,\n            transaction: setupTransaction,\n            validators: [validatorAddress],\n            signatures,\n            nonce: saltNonce\n        };\n    }\n}\nexport class Vault {\n    constructor(provider, vaultAddress) {\n        this.address = vaultAddress;\n        this.vaultInstance = new Contract(vaultAddress, StatelessVault.abi, provider);\n    }\n    async loadTransactions() {\n        const txs = [];\n        const configTopic = this.vaultInstance.interface.getEventTopic(\"Configuration\");\n        const failedTopic = this.vaultInstance.interface.getEventTopic(\"ExecutionFailure\");\n        const successTopic = this.vaultInstance.interface.getEventTopic(\"ExecutionSuccess\");\n        const events = await this.vaultInstance.queryFilter({\n            address: this.vaultInstance.address,\n            topics: [\n                [\n                    configTopic, failedTopic, successTopic\n                ]\n            ]\n        });\n        for (const e of events) {\n            if (e.topics[0] == configTopic) {\n                const config = this.vaultInstance.interface.decodeEventLog(\"Configuration\", e.data, e.topics);\n                if (config.currentNonce.eq(0)) {\n                    txs.push({\n                        action: \"config_update\",\n                        txHash: e.transactionHash\n                    });\n                }\n                else {\n                    txs.push({\n                        action: \"config_update\",\n                        txHash: e.transactionHash,\n                        nonce: config.currentNonce - 1\n                    });\n                }\n            }\n            else if (e.topics[0] == failedTopic) {\n                const exec = this.vaultInstance.interface.decodeEventLog(\"ExecutionFailure\", e.data, e.topics);\n                txs.push({\n                    action: \"executed_transaction\",\n                    vaultHash: exec.txHash,\n                    ethereumHash: e.transactionHash,\n                    nonce: exec.usedNonce,\n                    success: false\n                });\n            }\n            else if (e.topics[0] == successTopic) {\n                const exec = this.vaultInstance.interface.decodeEventLog(\"ExecutionSuccess\", e.data, e.topics);\n                txs.push({\n                    action: \"executed_transaction\",\n                    vaultHash: exec.txHash,\n                    ethereumHash: e.transactionHash,\n                    nonce: exec.usedNonce,\n                    success: true\n                });\n            }\n        }\n        return txs.reverse();\n    }\n    async loadConfig() {\n        const configTopic = this.vaultInstance.interface.getEventTopic(\"Configuration\");\n        const failedTopic = this.vaultInstance.interface.getEventTopic(\"ExecutionFailure\");\n        const successTopic = this.vaultInstance.interface.getEventTopic(\"ExecutionSuccess\");\n        const events = await this.vaultInstance.queryFilter({\n            address: this.vaultInstance.address,\n            topics: [\n                [\n                    configTopic, failedTopic, successTopic\n                ]\n            ]\n        });\n        const currentConfig = {\n            implementation: constants.AddressZero,\n            signatureChecker: constants.AddressZero,\n            requestGuard: constants.AddressZero,\n            fallbackHandler: constants.AddressZero,\n            signers: [],\n            threshold: BigNumber.from(0),\n            nonce: BigNumber.from(-1)\n        };\n        for (const e of events) {\n            if (e.topics[0] == configTopic) {\n                const config = this.vaultInstance.interface.decodeEventLog(\"Configuration\", e.data, e.topics);\n                if (config.currentNonce >= currentConfig.nonce) {\n                    currentConfig.signers = config.signers;\n                    currentConfig.threshold = config.threshold;\n                    currentConfig.nonce = config.currentNonce;\n                    currentConfig.implementation = config.implementation;\n                    currentConfig.signatureChecker = config.signatureChecker;\n                    currentConfig.requestGuard = config.requestGuard;\n                    currentConfig.fallbackHandler = config.fallbackHandler;\n                }\n            }\n            else if (e.topics[0] == failedTopic) {\n                const exec = this.vaultInstance.interface.decodeEventLog(\"ExecutionFailure\", e.data, e.topics);\n                if (currentConfig.nonce <= exec.usedNonce) {\n                    currentConfig.nonce = exec.usedNonce.add(1);\n                }\n            }\n            else if (e.topics[0] == successTopic) {\n                const exec = this.vaultInstance.interface.decodeEventLog(\"ExecutionSuccess\", e.data, e.topics);\n                console.log(exec);\n                if (currentConfig.nonce <= exec.usedNonce) {\n                    currentConfig.nonce = exec.usedNonce.add(1);\n                }\n            }\n            else {\n                console.warn(\"Unknown log\");\n            }\n        }\n        if (currentConfig.nonce.eq(-1))\n            throw Error(\"could not load config\");\n        return currentConfig;\n    }\n    async fetchTxByHash(ipfs, txHash) {\n        const hashData = await pullWithKeccak(ipfs, txHash);\n        const tx = await pullWithKeccak(ipfs, hashData.substring(68));\n        const txData = await pullWithKeccak(ipfs, tx.substring(3 * 64, 4 * 64));\n        const to = utils.getAddress(tx.substring(64 + 24, 2 * 64));\n        const value = BigNumber.from(\"0x\" + tx.substring(2 * 64, 3 * 64));\n        const data = \"0x\" + txData;\n        const operation = parseInt(tx.substring(4 * 64, 5 * 64), 16);\n        const minAvailableGas = BigNumber.from(\"0x\" + tx.substring(5 * 64, 6 * 64));\n        const nonce = BigNumber.from(\"0x\" + tx.substring(6 * 64, 7 * 64));\n        const metaHash = \"0x\" + tx.substring(7 * 64, 8 * 64);\n        let meta;\n        if (metaHash !== \"0x0000000000000000000000000000000000000000000000000000000000000000\") {\n            try {\n                meta = await pullWithKeccak(ipfs, metaHash, \"utf8\");\n            }\n            catch (e) {\n                console.error(e);\n            }\n        }\n        return {\n            to,\n            value: value.toHexString(),\n            data,\n            operation,\n            minAvailableGas: minAvailableGas.toHexString(),\n            nonce: nonce.toHexString(),\n            metaHash,\n            meta\n        };\n    }\n    async publishTx(ipfs, to, value, dataString, operation, nonce, meta) {\n        const metaData = meta ? JSON.stringify(meta) : null;\n        const metaHash = metaData ? utils.solidityKeccak256([\"string\"], [metaData]) : \"0x\";\n        if (metaData) {\n            console.log(\"Publish meta data\");\n            for await (const res of ipfs.add(metaData, { hashAlg: \"keccak-256\" })) {\n                console.log(`metadata: ${res.path}`);\n            }\n        }\n        const data = utils.arrayify(dataString);\n        const vaultDomain = new EIP712Domain({\n            chainId: 4,\n            verifyingContract: this.address,\n        });\n        const VaultTx = vaultDomain.createType('Transaction', [\n            { type: \"address\", name: \"to\" },\n            { type: \"uint256\", name: \"value\" },\n            { type: \"bytes\", name: \"data\" },\n            { type: \"uint8\", name: \"operation\" },\n            { type: \"uint256\", name: \"minAvailableGas\" },\n            { type: \"uint256\", name: \"nonce\" },\n            { type: \"bytes32\", name: \"metaHash\" },\n        ]);\n        const minAvailableGas = 0;\n        const vaultTx = new VaultTx({\n            to,\n            value: value.toHexString(),\n            data,\n            operation,\n            minAvailableGas,\n            nonce: nonce.toNumber(),\n            metaHash\n        });\n        // data\n        console.log(\"Publish data\");\n        for await (const res of ipfs.add(data, { hashAlg: \"keccak-256\" })) {\n            console.log(`metadata: ${res.path}`);\n        }\n        // TX_TYPEHASH, to, value, keccak256(data), operation, minAvailableGas, nonce\n        console.log(\"Publish tx\");\n        for await (const res of ipfs.add(vaultTx.encodeData(), { hashAlg: \"keccak-256\" })) {\n            console.log(`metadata: ${res.path}`);\n        }\n        // byte(0x19), byte(0x01), domainSeparator, txHash\n        console.log(\"Publish tx hash\");\n        const txHash = \"0x\" + vaultTx.signHash().toString('hex');\n        for await (const res of ipfs.add(vaultTx.encode(), { hashAlg: \"keccak-256\" })) {\n            console.log(`metadata: ${res.path}`);\n        }\n        const dataHash = await this.vaultInstance.generateTxHash(to, value, data, operation, minAvailableGas, nonce, metaHash);\n        if (txHash != dataHash)\n            throw Error(\"Invalid hash generated\");\n        return txHash;\n    }\n    async formatSignature(config, hashProvider, signatures, signer) {\n        let sigs;\n        let signers;\n        if (signatures) {\n            const dataHash = await hashProvider();\n            sigs = signatures.map((sig) => sig.slice(2));\n            let prevIndex = -1;\n            signers = signatures.map((sig) => {\n                const signer = utils.verifyMessage(utils.arrayify(dataHash), sig);\n                const signerIndex = config.signers.indexOf(signer, prevIndex + 1);\n                if (signerIndex <= prevIndex)\n                    throw Error(\"Invalid signer\");\n                prevIndex = signerIndex;\n                return signer;\n            });\n        }\n        else if (config.signers.length == 1) {\n            const singleSigner = await signer.getAddress();\n            if (config.signers.indexOf(singleSigner) < 0)\n                throw Error(\"Signer is not an owner\");\n            sigs = [utils.solidityPack([\"uint256\", \"uint256\", \"bytes1\"], [singleSigner, 0, \"0x01\"]).slice(2)];\n            signers = [singleSigner];\n        }\n        else {\n            throw Error(\"Cannot execute transaction due to missing confirmation\");\n        }\n        return { signaturesString: \"0x\" + sigs.join(\"\"), signers };\n    }\n    async buildExecData(transaction, signatures, signer) {\n        const config = await this.loadConfig();\n        if (!config.nonce.eq(transaction.nonce))\n            throw Error(\"Invalid nonce\");\n        const { signaturesString, signers } = await this.formatSignature(config, () => {\n            return this.vaultInstance.generateTxHash(transaction.to, transaction.value, transaction.data, transaction.operation, transaction.minAvailableGas, transaction.nonce, transaction.metaHash);\n        }, signatures, signer);\n        const validationData = await buildValidationData(config, signaturesString, signers);\n        //console.log(await this.vaultInstance.callStatic.execTransaction(to, value, data, operation, 0, config.nonce, \"0x\", validationData, true))\n        return {\n            wallet: this.address,\n            validationData,\n            transaction\n        };\n    }\n}\nexport class VaultSigner {\n    constructor(vault, signer) {\n        this.vault = vault;\n        this.signer = signer;\n    }\n    async signTx(transaction) {\n        const dataHash = await this.vault.vaultInstance.generateTxHash(transaction.to, transaction.value, transaction.data, transaction.operation, transaction.minAvailableGas, transaction.nonce, transaction.metaHash);\n        return prepareEthSignSignatureForSafe(await this.signer.signMessage(utils.arrayify(dataHash)));\n    }\n    async signTxFromHash(ipfs, txHash) {\n        const vaultTx = await this.vault.fetchTxByHash(ipfs, txHash);\n        return await this.signTx(vaultTx);\n    }\n    async signUpdate(newSigners, newThreshold, nonce) {\n        const config = await this.vault.loadConfig();\n        const dataHash = await this.vault.vaultInstance.generateConfigChangeHash(config.implementation, utils.solidityPack([\"address[]\"], [newSigners]), newThreshold, config.signatureChecker, config.requestGuard, config.fallbackHandler, \"0x\", nonce, \"0x\");\n        return prepareEthSignSignatureForSafe(await this.signer.signMessage(utils.arrayify(dataHash)));\n    }\n}\nexport class VaultExecutor {\n    constructor(vault, executor) {\n        this.vault = vault;\n        this.executor = executor;\n        this.writeVaultInstance = vault.vaultInstance.connect(executor);\n    }\n    async exec(to, value, data, operation, nonce, metaHash, signatures) {\n        const transaction = { to, value: value.toHexString(), data, operation, nonce: nonce.toHexString(), minAvailableGas: \"0x0\", metaHash };\n        const execData = await this.vault.buildExecData(transaction, signatures, this.executor);\n        //console.log(await this.vaultInstance.callStatic.execTransaction(to, value, data, operation, 0, config.nonce, \"0x\", validationData, true))\n        await this.writeVaultInstance.execTransaction(execData.transaction.to, execData.transaction.value, execData.transaction.data, execData.transaction.operation, execData.transaction.minAvailableGas, execData.transaction.nonce, execData.transaction.metaHash, execData.validationData, true);\n    }\n    async update(newSigners, newThreshold, nonce, signatures) {\n        const config = await this.vault.loadConfig();\n        if (!config.nonce.eq(nonce))\n            throw Error(\"Invalid nonce\");\n        const { signaturesString, signers } = await this.vault.formatSignature(config, () => {\n            return this.vault.vaultInstance.generateConfigChangeHash(config.implementation, utils.solidityPack([\"address[]\"], [newSigners]), newThreshold, config.signatureChecker, config.requestGuard, config.fallbackHandler, \"0x\", nonce, \"0x\");\n        }, signatures, this.executor);\n        const validationData = await buildValidationData(config, signaturesString, signers);\n        await this.writeVaultInstance.updateConfig(config.implementation, newSigners, newThreshold, config.signatureChecker, config.requestGuard, config.fallbackHandler, \"0x\", nonce, \"0x\", validationData);\n    }\n}\n//# sourceMappingURL=index.js.map","import { config } from 'dotenv'\n\nconfig()\n\nexport const chainNames: { [key: number]: string; } = {\n    1: \"mainnet\",\n    4: \"rinkeby\",\n    100: \"xdai\"\n}\n\nexport const rpcUrl: string = process.env.REACT_APP_RPC_URL!!\n\nexport const chainId: number = parseInt(process.env.REACT_APP_CHAIN_ID!!)\n\nexport const chainName: string = chainNames[chainId]","import { EthHashInfo } from '@gnosis.pm/safe-react-components'\nimport { ThemeColors } from '@gnosis.pm/safe-react-components/dist/theme'\nimport React from 'react'\nimport { chainName } from 'src/utils/config'\n\nconst AccountInfo: React.FC<{ address: string, className?: string, textColor?: ThemeColors }> = ({ address, className, textColor }) => {\n  if (!address) {\n    return null\n  }\n\n  return (\n    <EthHashInfo\n      hash={address}\n      textSize=\"xl\"\n      showCopyBtn\n      showIdenticon\n      showEtherscanBtn\n      shortenHash={4}\n      textColor={textColor || \"white\"}\n      className={className || \"address\"}\n      network={chainName}\n    />\n  )\n}\n\nexport default AccountInfo\n","import { rpcUrl } from \"src/utils/config\"\nimport { Signer, providers } from \"ethers\"\n\nlet localProvider = new providers.JsonRpcProvider({\n    url: rpcUrl\n})\n\nlet localSigner: Signer | undefined = undefined\n\nexport const loadProvider = (): providers.Provider => {\n    return localProvider\n}\n\nexport const setLocalSigner = (signer: Signer) => {\n    localSigner = signer;\n}\n\nexport const clearLocalSigner = () => {\n    localSigner = undefined\n}\n\nexport const loadSigner = (): Signer => {\n    if (!localSigner) localProvider.getSigner()\n    return localSigner!!\n}","import { Vault } from \"@rmeissner/stateless-vault-sdk\"\nimport { loadProvider } from \"./ethereumRepository\"\nimport { utils } from 'ethers'\n\nconst VAULTS_STORAGE_KEY = \"vault_repository.vaults\"\nconst SELECTED_VAULT_STORAGE_KEY = \"vault_repository.selected_vault\"\n\ninterface StorageHolder<T> {\n    readonly version: number,\n    readonly value: T\n}\n\nconst loadVaultStorage = (): { [key: string]: string} => {\n    const holder: StorageHolder<{ [key: string]: string}> = JSON.parse(localStorage.getItem(VAULTS_STORAGE_KEY)!!)\n    if (holder.version == 0) throw Error(\"Unknown storage version \" + holder.version)\n    return holder.value\n}\n\nconst writeVaultStorage = (vaults: { [key: string]: string})  => {\n    const holder: StorageHolder<{ [key: string]: string}> = {\n        version: 0,\n        value: vaults\n    }\n    localStorage.setItem(VAULTS_STORAGE_KEY, JSON.stringify(holder))\n}\n\nexport const loadLastSelectedVault = async (): Promise<string | undefined> => {\n    const store = localStorage.getItem(SELECTED_VAULT_STORAGE_KEY)\n    if (!store) return undefined\n    const holder: StorageHolder<string> = JSON.parse(store)\n    if (holder.version == 0) throw Error(\"Unknown storage version \" + holder.version)\n    return holder.value\n}\n\nexport const loadVaultName = async(address: string): Promise<string> => {\n    const vaults = await loadVaultStorage()\n    return vaults[address]\n}\n\nexport const setLastSelectedVault = async (address: string) => {\n    const holder: StorageHolder<string> = {\n        version: 0,\n        value: address\n    }\n    localStorage.setItem(SELECTED_VAULT_STORAGE_KEY, JSON.stringify(holder))\n}\n\nexport const loadVaults = async(): Promise<[string, string][]> => {\n    try {\n        const vaults = loadVaultStorage()\n        return Object.entries(vaults)\n    } catch (e) {\n        console.log(e)\n        return []\n    }\n}\n\nexport const setVault = async(address: string, name: string): Promise<void> => {\n    try {\n        const vaults = loadVaultStorage()\n        vaults[address] = name\n        writeVaultStorage(vaults)\n    } catch (e) {\n        console.log(e)\n    }\n}\n\nexport const removeVault = async(address: string): Promise<void> => {\n    try {\n        const vaults = loadVaultStorage()\n        delete vaults[address]\n        writeVaultStorage(vaults)\n    } catch (e) {\n        console.log(e)\n    }\n}\n\nexport const getVaultInstance = async(address: string): Promise<Vault> => {\n    if (!utils.isAddress(address)) throw Error(\"Invalid Address\")\n    return new Vault(loadProvider(), address)\n}","import * as React from 'react'\nimport { Vault, VaultAction } from '@rmeissner/stateless-vault-sdk';\nimport { createStyles, WithStyles, withStyles, Box, List, ListItem } from '@material-ui/core';\n\nconst styles = createStyles({\n    list: {\n    },\n    item: {\n        display: 'block'\n    }\n})\n\ninterface Props extends WithStyles<typeof styles> {\n    vault: Vault\n}\n\nconst VaultTransactions: React.FC<Props> = ({ vault, classes }) => {\n    console.log(\"Load Transactions\")\n    const [transactions, setTransactions] = React.useState<VaultAction[]>([])\n    const loadTransactions = React.useCallback(async () => {\n        try {\n            setTransactions(await vault.loadTransactions())\n        } catch (e) {\n            console.log(`Could not load transactions`)\n            console.error(e)\n        }\n    }, [vault, setTransactions])\n    React.useEffect(() => {\n        loadTransactions()\n    }, [])\n    const listItems = transactions.map((tx, index) => {\n        switch (tx.action) {\n            case \"config_update\":\n                return (<ListItem className={classes.item}>\n                    <Box>Config Update {index}/{transactions.length}</Box>\n                    <Box textOverflow=\"ellipsis\" overflow=\"hidden\">{tx.txHash}</Box>\n                </ListItem>);\n            case \"executed_transaction\":\n                if (tx.success) {\n                    return (<ListItem className={classes.item}>\n                        <Box>Tx success (nonce {tx.nonce.toString()} {index}/{transactions.length})</Box>\n                        <Box textOverflow=\"ellipsis\" overflow=\"hidden\">{tx.ethereumHash}</Box>\n                    </ListItem>);\n                } else {\n                    return (<ListItem className={classes.item}>\n                        <Box>Tx failure (nonce {tx.nonce.toString()})</Box>\n                        <Box textOverflow=\"ellipsis\" overflow=\"hidden\">{tx.ethereumHash}</Box>\n                    </ListItem>);\n                }\n        }\n    })\n    console.log({ listItems })\n    return transactions.length > 0 ? (\n        <List className={classes.list}>\n            { listItems }\n        </List>\n    ) : (\n            <p>No Transactions yet</p>\n        )\n}\n\nexport default withStyles(styles)(VaultTransactions)","import * as React from 'react'\nimport { Vault, VaultConfig } from '@rmeissner/stateless-vault-sdk'\nimport { Box, createStyles, WithStyles, withStyles, List, ListItem } from '@material-ui/core'\nimport WalletInfo from '../WalletInfo'\n\nconst styles = createStyles({\n    list: {\n    },\n    content: {\n    },\n    item: {\n        display: 'flex',\n        justifyContent: 'center',\n        maxWidth: '100vw'\n    }\n})\n\ninterface Props extends WithStyles<typeof styles> {\n    vault: Vault\n}\n\nconst VaultSettings: React.FC<Props> = ({ vault, classes }) => {\n    const [configuration, setConfiguration] = React.useState<VaultConfig | undefined>(undefined)\n    const loadConfig = React.useCallback(async () => {\n        try {\n            setConfiguration(await vault.loadConfig())\n        } catch (e) {\n            console.log(`Could not load transactions`)\n            console.error(e)\n        }\n    }, [vault, setConfiguration])\n    React.useEffect(() => {\n        loadConfig()\n    }, [])\n    return configuration ? (\n        <div className={classes.content}>\n            <p>Threshold</p>\n            <Box>{configuration.threshold.toString()}</Box>\n            <p>Nonce</p>\n            <Box>{configuration.nonce.toString()}</Box>\n            <p>Signers</p>\n            <List className={classes.list}>\n                {configuration.signers.map((signer) => {\n                    return (\n                        <ListItem className={classes.item}><WalletInfo address={signer} textColor=\"text\" /></ListItem>\n                    )\n                })}\n            </List>\n            <p>Implementation</p>\n            <Box className={classes.item}><WalletInfo address={configuration.implementation} textColor=\"text\" /></Box>\n        </div>\n    ) : (\n            <p>Loading config</p>\n        )\n}\n\nexport default withStyles(styles)(VaultSettings)","import * as React from 'react'\nimport WalletInfo from 'src/components/WalletInfo'\nimport { Vault } from '@rmeissner/stateless-vault-sdk';\nimport { Redirect, Route, Switch, useHistory, useParams, useRouteMatch } from \"react-router-dom\";\nimport { AppBar, BottomNavigation, BottomNavigationAction, Container, createStyles, Toolbar, WithStyles, withStyles } from '@material-ui/core';\nimport { Timeline, Settings } from '@material-ui/icons';\nimport { getVaultInstance } from 'src/logic/vaultRepository';\nimport styled from 'styled-components'\nimport VaultTransactions from './VaultTransactions';\nimport VaultSettings from './VaultSettings';\n\nconst styles = createStyles({\n    toolbar: {\n        justifyContent: 'center',\n        maxWidth: '100vw'\n    },\n    content: {\n        paddingBottom: '64px',\n        flex: \"1 1 auto\",\n        maxWidth: '100vw'\n    },\n    navigation: {\n        height: '64px',\n        position: 'fixed',\n        bottom: 0,\n        width: '100vw'\n    }\n})\n\nconst VaultHomeContainer = styled.main`\n  display: flex;\n  flex-direction: column;\n  align-items: top;\n  text-align: center;\n  flex-grow: 1;\n  width: 100vw;\n  height: 100vh;\n`\n\ninterface Active {\n    address: string,\n    instance: Vault\n}\n\ninterface Path {\n    vaultAddress: string\n}\n\nconst VaultHome: React.FC<WithStyles<typeof styles>> = ({ classes }) => {\n    const match = useRouteMatch()\n    const [active, setActive] = React.useState<Active | undefined>(undefined)\n    const history = useHistory()\n    const { vaultAddress } = useParams<Path>()\n    React.useEffect(() => {\n        const loadActive = async () => {\n            try {\n                const instance = await getVaultInstance(vaultAddress)\n                setActive({\n                    address: vaultAddress,\n                    instance\n                })\n            } catch (e) {\n                console.log(`Could not load Vault ${vaultAddress}`)\n                console.error(e)\n                history.push(`/`)\n            }\n        }\n        loadActive()\n    }, [vaultAddress, setActive])\n    if (!active) return (<>Loading</>)\n    return (\n        <VaultHomeContainer>\n            <AppBar position=\"fixed\">\n                <Toolbar className={classes.toolbar}>\n                    <WalletInfo address={active.address!} />\n                </Toolbar>\n            </AppBar>\n            <Toolbar />\n            <Container className={classes.content}>\n                <Switch>\n                    <Route path={`${match.path}/transactions`}>\n                        <VaultTransactions vault={active.instance} />\n                    </Route>\n                    <Route path={`${match.path}/config`}>\n                        <VaultSettings vault={active.instance} />\n                    </Route>\n                    <Route path=\"*\">\n                        <Redirect to={`${match.url}/transactions`} />\n                    </Route>\n                </Switch>\n            </Container>\n            <BottomNavigation\n                className={classes.navigation}\n                onChange={(_, newValue) => {\n                    switch (newValue) {\n                        case 1:\n                            history.push(`${match.url}/config`)\n                            break;\n                        default:\n                            history.push(`${match.url}/transactions`)\n                            break;\n                    }\n                }}\n                showLabels\n            >\n                <BottomNavigationAction label=\"Transactions\" icon={<Timeline />} />\n                <BottomNavigationAction label=\"Settings\" icon={<Settings />} />\n            </BottomNavigation>\n        </VaultHomeContainer>\n    )\n}\n\nexport default withStyles(styles)(VaultHome)","export default __webpack_public_path__ + \"static/media/yacate-logo.30ab8735.svg\";","import AppLogo from 'src/assets/icons/yacate-logo.svg'\nimport * as React from 'react'\nimport styled from 'styled-components'\n\nconst OnboardingContainer = styled.main`\n  display: flex;\n  flex-direction: column;\n  flex-grow: 1;\n  align-items: center;\n  text-align: center;\n`\n\nconst SHeading = styled.h1`\n@media screen and (max-width: 768px) {\n  font-size: 1.2em;\n}\n`\ntype Props = {\n  onboardingDone: () => void\n}\n\nconst Welcome: React.FC<Props> = () => {\n    return (\n        <OnboardingContainer>\n            <img src={AppLogo} alt=\"App Logo\" width=\"100\"></img>\n            <SHeading>Yacate - A smart wallet based on the Stateless Vault</SHeading>\n            <p>Start by adding a Vault</p>\n        </OnboardingContainer>\n    )\n}\n\nexport default Welcome","export const undefinedOnError = async<T>(func: Promise<T>): Promise<T | undefined> => {\n    try {\n        return await func\n    } catch (e) {\n        console.error(e)\n        return undefined\n    }\n}","import React from 'react'\nimport { Route, Switch, HashRouter as Router, useHistory } from \"react-router-dom\"\nimport VaultHome from './vault/VaultHome'\nimport Welcome from './onboarding/Welcome'\nimport { loadLastSelectedVault } from 'src/logic/vaultRepository'\nimport { undefinedOnError } from 'src/utils/general'\n\n\nconst App: React.FC = () => {\n  const history = useHistory()\n  const loadSelected = React.useCallback(async () => {\n    const selectedVault = await undefinedOnError(loadLastSelectedVault())\n    if (selectedVault) {\n      history.push(`/${selectedVault}`)\n    }\n  }, [])\n\n  React.useEffect(() => {\n    loadSelected()\n  }, [loadSelected])\n\n  return (\n    <Router>\n      <Switch>\n        <Route path=\"/:vaultAddress\">\n          <VaultHome />\n        </Route>\n        <Route path=\"/\">\n          <Welcome onboardingDone={loadSelected} />\n        </Route>\n      </Switch>\n    </Router>\n  )\n}\n\nexport default App\n","import avertaBoldFont from '@gnosis.pm/safe-react-components/dist/fonts/averta-bold.woff2'\nimport avertaFont from '@gnosis.pm/safe-react-components/dist/fonts/averta-normal.woff2'\nimport { createGlobalStyle } from 'styled-components'\nimport { normalize } from 'styled-normalize'\n\nconst GlobalStyles = createGlobalStyle`\n  ${normalize}\n\n  @font-face {\n    font-family: 'Averta';\n    font-display: swap;\n    src: local('Averta'), local('Averta Bold'),\n    url(${avertaFont}) format('woff2'),\n    url(${avertaBoldFont}) format('woff');\n  }\n\n  body {\n    font-family: 'Averta', sans-serif;\n    margin: 0;\n    padding: 0;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    width: 100vw;\n    height: 100vh;\n  }\n\n  .web3connect-connect-button {\n    background-color: #008c73 !important;\n  }\n\n  .walletconnect-qrcode__base {\n    left: 0;\n  }\n\n  a {\n    color: #008c73;\n  }\n\n  .address p {\n    font-family: 'Roboto', monospace;\n  }\n`\n\nexport default GlobalStyles\n","import { theme } from '@gnosis.pm/safe-react-components'\nimport React from 'react'\nimport App from 'src/components/App'\nimport GlobalStyles from 'src/styles/global'\nimport { ThemeProvider } from 'styled-components'\n\nconst Root: React.FC = () => (\n  <React.StrictMode>\n    <ThemeProvider theme={theme}>\n      <GlobalStyles />\n      <App />\n    </ThemeProvider>\n  </React.StrictMode>\n)\n\nexport default Root\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n)\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void\n  onUpdate?: (registration: ServiceWorkerRegistration) => void\n}\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href)\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config)\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          )\n        })\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config)\n      }\n    })\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing\n        if (installingWorker == null) {\n          return\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              )\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration)\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.')\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration)\n              }\n            }\n          }\n        }\n      }\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error)\n    })\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type')\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload()\n          })\n        })\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config)\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      )\n    })\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then((registration) => {\n      registration.unregister()\n    })\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport Root from './Root'\nimport * as serviceWorker from './serviceWorkerRegistraction'\n\nReactDOM.render(<Root />, document.getElementById('root'))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n","import CID from 'cids';\nimport { utils } from 'ethers';\nconst addHexPrefix = (input) => input.toLowerCase().startsWith(\"0x\") ? input : \"0x\" + input;\nexport const pullWithKeccak = async (ipfs, hashPart, encoding) => {\n    const multhash = Buffer.concat([utils.arrayify(\"0x1b20\"), utils.arrayify(addHexPrefix(hashPart))]);\n    const cid = new CID(1, \"raw\", multhash, \"base32\");\n    let out = \"\";\n    for await (const file of ipfs.get(cid.toString())) {\n        if (!file.content)\n            continue;\n        const content = [];\n        for await (const chunk of file.content) {\n            content.push(chunk);\n        }\n        out += content.map(c => c.toString(encoding || 'hex')).join();\n    }\n    return out;\n};\n//# sourceMappingURL=ipfs.js.map"],"sourceRoot":""}