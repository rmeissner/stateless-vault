{"version":3,"sources":["../../../src/utils/signatures.ts","../../../src/utils/ipfs.ts","../../src/index.ts","../../../src/utils/proof.ts","utils/config.ts","components/WalletInfo.tsx","logic/ethereumRepository.ts","logic/vaultRepository.ts","components/vault/transactions/VaultTransactions.tsx","components/vault/transactions/VaultTransactionDetails.tsx","components/vault/settings/AddVaultDialog.tsx","components/vault/settings/VaultSettings.tsx","components/vault/settings/VaultSelectionDialog.tsx","components/vault/apps/messaging.ts","components/vault/apps/TransactionProposalDialog.tsx","components/vault/apps/VaultApps.tsx","components/vault/VaultHome.tsx","assets/icons/yacate-logo.svg","utils/general.ts","components/onboarding/Welcome.tsx","components/App.tsx","styles/global.ts","Root.tsx","serviceWorkerRegistraction.ts","index.tsx"],"names":["prepareEthSignSignatureForSafe","signature","replace","chunk","e","right","config","chainName","1","4","100","parseInt","process","AccountInfo","address","className","textColor","hash","textSize","showCopyBtn","showIdenticon","showEtherscanBtn","shortenHash","network","localProvider","providers","JsonRpcProvider","url","VAULTS_STORAGE_KEY","PROPOSAL_STORAGE_KEY_PREFIX","SELECTED_VAULT_STORAGE_KEY","STORAGE_IPFS_CACHE_PREFIX","ipfs","IpfsClient","host","port","protocol","loadVaultStorage","stored","localStorage","getItem","holder","JSON","parse","version","Error","value","writeVaultStorage","vaults","setItem","stringify","loadLastSelectedVault","a","store","undefined","managesVault","removeLastSelectedVault","removeItem","setLastSelectedVault","loadVaults","Object","keys","sort","map","name","console","log","setVault","removeVault","getVaultInstance","utils","isAddress","Vault","cachedLoader","key","encoding","cached","error","pullWithKeccak","loadTransactionDetails","vault","vaultHash","fetchTxByHash","loadProposalStorage","vaultAddress","writeProposalStorage","loadTransactionProposals","proposals","entries","transaction","left","BigNumber","from","nonce","sub","toNumber","removeTransactionProposals","vaultHashes","addTransactionProposal","publishTx","to","data","operation","meta","metaHash","styles","createStyles","list","item","display","withStyles","classes","React","transactions","setTransactions","setProposals","loadItems","loadTransactions","tx","action","filter","val","listItems","ListItem","Box","textOverflow","overflow","txHash","success","location","pathname","toString","ethereumHash","proposalItems","proposal","length","List","Typography","details","flex","overflowWrap","maxWidth","justifyContent","history","useHistory","useParams","setDetails","loadDetails","goBack","WalletInfo","formatEther","minAvailableGas","remove","margin","open","onClose","vaultName","setVaultName","setVaultAddress","inputError","setInputError","addVault","cleanAddress","getAddress","push","Dialog","scroll","aria-labelledby","aria-describedby","DialogTitle","id","DialogContent","dividers","DialogContentText","tabIndex","TextField","label","onChange","target","helperText","DialogActions","Button","onClick","color","content","configuration","setConfiguration","loadConfig","threshold","signers","signer","implementation","onAdd","setVaults","select","init","Delete","sendMessageToIframe","iframe","appUrl","message","requestId","requestWithMessage","Math","trunc","window","performance","now","contentWindow","postMessage","handleIframeMessage","messageId","messagePayload","handler","SDK_MESSAGES","SEND_TRANSACTIONS","onTransactionProposal","SEND_TRANSACTIONS_V2","payload","txs","SAFE_APP_SDK_INITIALIZED","onSDKIntitalized","buildMultiSend","metaString","app","onConfirm","onReject","proposeTx","toHexString","rejectTx","appContainer","border","frameborder","width","height","proposalParams","setProposalParams","appFrame","handlers","current","INTERFACE_MESSAGES","ON_SAFE_INFO","safeAddress","ethBalance","handleTransactionConfirmation","TRANSACTION_CONFIRMED","safeTxHash","handleTransactionRejection","TRANSACTION_REJECTED","loaded","messageHandler","origin","includes","iframeMessageHandler","addEventListener","removeEventListener","ref","onLoad","src","title","toolbar","background","paddingBottom","navigation","position","bottom","VaultHomeContainer","styled","main","match","useRouteMatch","active","setActive","showVaultSelection","setShowVaultSelection","showAddVault","setShowAddVault","instance","loadActive","AppBar","Toolbar","ArrowDropDown","Container","path","BottomNavigation","_","newValue","showLabels","BottomNavigationAction","icon","Timeline","Apps","Settings","undefinedOnError","func","OnboardingContainer","SHeading","h1","Welcome","loading","setLoading","loadSelected","selectedVault","AppLogo","alt","size","App","GlobalStyles","createGlobalStyle","normalize","avertaFont","avertaBoldFont","Root","StrictMode","theme","Boolean","hostname","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.878941d7.chunk.js","sourcesContent":["export const prepareEthSignSignatureForSafe = (signature) => {\n    return signature.replace(/00$/, \"1f\").replace(/1b$/, \"1f\").replace(/01$/, \"20\").replace(/1c$/, \"20\");\n};\n//# sourceMappingURL=signatures.js.map","import CID from 'cids';\nconst removeHexPrefix = (input) => input.toLowerCase().startsWith(\"0x\") ? input.slice(2) : input;\nexport const pullWithKeccak = async (ipfs, hashPart, encoding) => {\n    const multhash = Buffer.concat([Buffer.from(\"1b20\", \"hex\"), Buffer.from(removeHexPrefix(hashPart), \"hex\")]);\n    const cid = new CID(1, \"raw\", multhash, \"base32\");\n    let out = \"\";\n    for await (const file of ipfs.get(cid.toString())) {\n        if (!file.content)\n            continue;\n        const content = [];\n        for await (const chunk of file.content) {\n            content.push(chunk);\n        }\n        out += content.map(c => c.toString(encoding || 'hex')).join();\n    }\n    return out;\n};\n//# sourceMappingURL=ipfs.js.map","import FactoryAbi from './abis/Factory.json';\nimport EIP712Domain from \"eth-typed-data\";\nimport { Contract, constants, utils, BigNumber } from 'ethers';\nimport { buildValidationData } from './utils/proof';\nimport { pullWithKeccak } from './utils/ipfs';\nimport { prepareEthSignSignatureForSafe } from './utils/signatures';\nimport StatelessVault from '@rmeissner/stateless-vault-contracts/build/contracts/StatelessVault.json';\nimport Initializor from '@rmeissner/stateless-vault-contracts/build/contracts/Initializor.json';\nimport RelayedFactory from '@rmeissner/stateless-vault-contracts/build/contracts/ProxyFactoryWithInitializor.json';\nexport { pullWithKeccak };\nexport class BaseFactory {\n    constructor() {\n        this.vaultInterface = Contract.getInterface(StatelessVault.abi);\n    }\n    async creationData(vaultSetup) {\n        return this.vaultInterface.encodeFunctionData(\"setup(address[],uint256,address,address,address)\", [vaultSetup.signers, vaultSetup.threshold, constants.AddressZero, constants.AddressZero, constants.AddressZero]);\n    }\n}\nexport class LocalVaultFactory extends BaseFactory {\n    constructor(config) {\n        super();\n        this.config = config;\n        this.factoryInstance = new Contract(config.factoryAddress, FactoryAbi, config.signer);\n    }\n    async calculateAddress(initializer, saltNonce) {\n        const initializerHash = utils.solidityKeccak256([\"bytes\"], [initializer]);\n        const salt = utils.solidityKeccak256(['bytes32', 'uint256'], [initializerHash, saltNonce]);\n        const proxyCreationCode = await this.factoryInstance.proxyCreationCode();\n        const proxyDeploymentCode = utils.solidityPack(['bytes', 'uint256'], [proxyCreationCode, this.config.vaultImplementationAddress]);\n        const proxyDeploymentCodeHash = utils.solidityKeccak256([\"bytes\"], [proxyDeploymentCode]);\n        const address = utils.solidityKeccak256(['bytes1', 'address', 'bytes32', 'bytes32'], [\"0xFF\", this.config.factoryAddress, salt, proxyDeploymentCodeHash]);\n        return \"0x\" + address.slice(-40);\n    }\n    async create(vaultSetup, saltString) {\n        const initializer = await this.creationData(vaultSetup);\n        const saltNonce = utils.keccak256(Buffer.from(saltString || `${new Date()}`));\n        try {\n            const tx = await this.factoryInstance.createProxyWithNonce(this.config.vaultImplementationAddress, initializer, saltNonce);\n            await tx.wait();\n            console.log(tx);\n        }\n        catch (e) { }\n        const address = await this.calculateAddress(initializer, saltNonce);\n        return new Vault(this.config.signer.provider, address);\n    }\n}\nexport class RelayedVaultFactory extends BaseFactory {\n    constructor(config) {\n        super();\n        this.initializorInterface = Contract.getInterface(Initializor.abi);\n        this.config = config;\n        this.relayFactoryInstance = new Contract(config.relayFactoryAddress, RelayedFactory.abi, config.provider);\n        this.factoryInstance = new Contract(config.factoryAddress, FactoryAbi, config.provider);\n    }\n    async calculateAddress(saltNonce, validators, intializor) {\n        const proxyCreationData = this.initializorInterface.encodeFunctionData(\"setValidators\", [validators]);\n        const intializorAddress = intializor || await this.relayFactoryInstance.callStatic.initializor();\n        const initializerHash = utils.solidityKeccak256([\"bytes\"], [proxyCreationData]);\n        const salt = utils.solidityKeccak256(['bytes32', 'uint256'], [initializerHash, saltNonce]);\n        const proxyCreationCode = await this.factoryInstance.proxyCreationCode();\n        const proxyDeploymentCode = utils.solidityPack(['bytes', 'uint256'], [proxyCreationCode, intializorAddress]);\n        const proxyDeploymentCodeHash = utils.solidityKeccak256([\"bytes\"], [proxyDeploymentCode]);\n        const address = utils.solidityKeccak256(['bytes1', 'address', 'bytes32', 'bytes32'], [\"0xFF\", this.config.factoryAddress, salt, proxyDeploymentCodeHash]);\n        return \"0x\" + address.slice(-40);\n    }\n    saltNonce(saltString) {\n        return utils.keccak256(Buffer.from(saltString || `${new Date()}`));\n    }\n    async relayData(validator, setupTransaction, saltNonce) {\n        const intializorAddress = await this.relayFactoryInstance.callStatic.initializor();\n        const initializor = new Contract(intializorAddress, this.initializorInterface, this.config.provider);\n        const validatorAddress = await validator.getAddress();\n        const vaultAddress = await this.calculateAddress(saltNonce, [validatorAddress], intializorAddress);\n        const setupHash = await initializor.callStatic.generateSetupHashForAddress(vaultAddress, this.config.vaultImplementationAddress, setupTransaction.to, setupTransaction.value, setupTransaction.data, setupTransaction.operation, utils.solidityPack([\"address[]\"], [[validatorAddress]]));\n        const signatures = prepareEthSignSignatureForSafe(await validator.signMessage(utils.arrayify(setupHash)));\n        return {\n            implementation: this.config.vaultImplementationAddress,\n            transaction: setupTransaction,\n            validators: [validatorAddress],\n            signatures,\n            nonce: saltNonce\n        };\n    }\n}\nexport var VaultTransactionStatus;\n(function (VaultTransactionStatus) {\n    VaultTransactionStatus[VaultTransactionStatus[\"SUCCESS\"] = 0] = \"SUCCESS\";\n    VaultTransactionStatus[VaultTransactionStatus[\"FAILED\"] = 1] = \"FAILED\";\n    VaultTransactionStatus[VaultTransactionStatus[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n})(VaultTransactionStatus || (VaultTransactionStatus = {}));\nexport class Vault {\n    constructor(provider, vaultAddress) {\n        this.address = vaultAddress;\n        this.vaultInstance = new Contract(vaultAddress, StatelessVault.abi, provider);\n    }\n    async loadTransactions() {\n        const txs = [];\n        const configTopic = this.vaultInstance.interface.getEventTopic(\"Configuration\");\n        const failedTopic = this.vaultInstance.interface.getEventTopic(\"ExecutionFailure\");\n        const successTopic = this.vaultInstance.interface.getEventTopic(\"ExecutionSuccess\");\n        const events = await this.vaultInstance.queryFilter({\n            address: this.vaultInstance.address,\n            topics: [\n                [\n                    configTopic, failedTopic, successTopic\n                ]\n            ]\n        });\n        for (const e of events) {\n            if (e.topics[0] == configTopic) {\n                const config = this.vaultInstance.interface.decodeEventLog(\"Configuration\", e.data, e.topics);\n                if (config.currentNonce.eq(0)) {\n                    txs.push({\n                        action: \"config_update\",\n                        txHash: e.transactionHash\n                    });\n                }\n                else {\n                    txs.push({\n                        action: \"config_update\",\n                        txHash: e.transactionHash,\n                        nonce: config.currentNonce - 1\n                    });\n                }\n            }\n            else if (e.topics[0] == failedTopic) {\n                const exec = this.vaultInstance.interface.decodeEventLog(\"ExecutionFailure\", e.data, e.topics);\n                txs.push({\n                    action: \"executed_transaction\",\n                    vaultHash: exec.txHash,\n                    ethereumHash: e.transactionHash,\n                    nonce: exec.usedNonce,\n                    success: false\n                });\n            }\n            else if (e.topics[0] == successTopic) {\n                const exec = this.vaultInstance.interface.decodeEventLog(\"ExecutionSuccess\", e.data, e.topics);\n                txs.push({\n                    action: \"executed_transaction\",\n                    vaultHash: exec.txHash,\n                    ethereumHash: e.transactionHash,\n                    nonce: exec.usedNonce,\n                    success: true\n                });\n            }\n        }\n        return txs.reverse();\n    }\n    async loadTransactionState(vaultHash) {\n        const failedTopic = this.vaultInstance.interface.getEventTopic(\"ExecutionFailure\");\n        const successTopic = this.vaultInstance.interface.getEventTopic(\"ExecutionSuccess\");\n        const events = await this.vaultInstance.queryFilter({\n            address: this.vaultInstance.address,\n            topics: [\n                [\n                    failedTopic, successTopic\n                ],\n                null,\n                vaultHash\n            ]\n        });\n        if (events.length != 1)\n            return VaultTransactionStatus.UNKNOWN;\n        return events.length[0].topics[0] === successTopic ? VaultTransactionStatus.SUCCESS : VaultTransactionStatus.FAILED;\n    }\n    async loadConfig() {\n        const configTopic = this.vaultInstance.interface.getEventTopic(\"Configuration\");\n        const failedTopic = this.vaultInstance.interface.getEventTopic(\"ExecutionFailure\");\n        const successTopic = this.vaultInstance.interface.getEventTopic(\"ExecutionSuccess\");\n        const events = await this.vaultInstance.queryFilter({\n            address: this.vaultInstance.address,\n            topics: [\n                [\n                    configTopic, failedTopic, successTopic\n                ]\n            ]\n        });\n        const currentConfig = {\n            implementation: constants.AddressZero,\n            signatureChecker: constants.AddressZero,\n            requestGuard: constants.AddressZero,\n            fallbackHandler: constants.AddressZero,\n            signers: [],\n            threshold: BigNumber.from(0),\n            nonce: BigNumber.from(-1)\n        };\n        for (const e of events) {\n            if (e.topics[0] == configTopic) {\n                const config = this.vaultInstance.interface.decodeEventLog(\"Configuration\", e.data, e.topics);\n                if (config.currentNonce >= currentConfig.nonce) {\n                    currentConfig.signers = config.signers;\n                    currentConfig.threshold = config.threshold;\n                    currentConfig.nonce = config.currentNonce;\n                    currentConfig.implementation = config.implementation;\n                    currentConfig.signatureChecker = config.signatureChecker;\n                    currentConfig.requestGuard = config.requestGuard;\n                    currentConfig.fallbackHandler = config.fallbackHandler;\n                }\n            }\n            else if (e.topics[0] == failedTopic) {\n                const exec = this.vaultInstance.interface.decodeEventLog(\"ExecutionFailure\", e.data, e.topics);\n                if (currentConfig.nonce <= exec.usedNonce) {\n                    currentConfig.nonce = exec.usedNonce.add(1);\n                }\n            }\n            else if (e.topics[0] == successTopic) {\n                const exec = this.vaultInstance.interface.decodeEventLog(\"ExecutionSuccess\", e.data, e.topics);\n                console.log(exec);\n                if (currentConfig.nonce <= exec.usedNonce) {\n                    currentConfig.nonce = exec.usedNonce.add(1);\n                }\n            }\n            else {\n                console.warn(\"Unknown log\");\n            }\n        }\n        if (currentConfig.nonce.eq(-1))\n            throw Error(\"could not load config\");\n        return currentConfig;\n    }\n    async pullWithLoader(ipfs, key, loader, encoding) {\n        if (!loader)\n            pullWithKeccak(ipfs, key, encoding);\n        return loader(key, encoding);\n    }\n    async fetchTxByHash(ipfs, txHash, loader) {\n        const hashData = await this.pullWithLoader(ipfs, txHash, loader);\n        const tx = await this.pullWithLoader(ipfs, hashData.substring(68), loader);\n        const txData = await this.pullWithLoader(ipfs, tx.substring(3 * 64, 4 * 64), loader);\n        const to = utils.getAddress(tx.substring(64 + 24, 2 * 64));\n        const value = BigNumber.from(\"0x\" + tx.substring(2 * 64, 3 * 64));\n        const data = \"0x\" + txData;\n        const operation = parseInt(tx.substring(4 * 64, 5 * 64), 16);\n        const minAvailableGas = BigNumber.from(\"0x\" + tx.substring(5 * 64, 6 * 64));\n        const nonce = BigNumber.from(\"0x\" + tx.substring(6 * 64, 7 * 64));\n        const metaHash = \"0x\" + tx.substring(7 * 64, 8 * 64);\n        let meta;\n        if (metaHash !== \"0x0000000000000000000000000000000000000000000000000000000000000000\") {\n            try {\n                meta = await this.pullWithLoader(ipfs, metaHash, loader, \"utf8\");\n            }\n            catch (e) {\n                console.error(e);\n            }\n        }\n        return {\n            to,\n            value: value.toHexString(),\n            data,\n            operation,\n            minAvailableGas: minAvailableGas.toHexString(),\n            nonce: nonce.toHexString(),\n            metaHash,\n            meta\n        };\n    }\n    async publishTx(ipfs, to, value, dataString, operation, nonce, meta) {\n        const metaHash = meta ? utils.solidityKeccak256([\"string\"], [meta]) : \"0x\";\n        if (meta) {\n            console.log(\"Publish meta data\");\n            {\n                const res = await ipfs.add(meta, { hashAlg: \"keccak-256\" });\n                console.log(`metadata: ${res.path}`);\n            }\n        }\n        const data = utils.arrayify(dataString);\n        const vaultDomain = new EIP712Domain({\n            chainId: 4,\n            verifyingContract: this.address,\n        });\n        const VaultTx = vaultDomain.createType('Transaction', [\n            { type: \"address\", name: \"to\" },\n            { type: \"uint256\", name: \"value\" },\n            { type: \"bytes\", name: \"data\" },\n            { type: \"uint8\", name: \"operation\" },\n            { type: \"uint256\", name: \"minAvailableGas\" },\n            { type: \"uint256\", name: \"nonce\" },\n            { type: \"bytes32\", name: \"metaHash\" },\n        ]);\n        const minAvailableGas = 0;\n        const vaultTx = new VaultTx({\n            to,\n            value: value.toHexString(),\n            data,\n            operation,\n            minAvailableGas,\n            nonce: nonce.toNumber(),\n            metaHash\n        });\n        // data\n        console.log(\"Publish data\");\n        {\n            const res = await ipfs.add(data, { hashAlg: \"keccak-256\" });\n            console.log(`metadata: ${res.path}`);\n        }\n        // TX_TYPEHASH, to, value, keccak256(data), operation, minAvailableGas, nonce\n        console.log(\"Publish tx\");\n        {\n            const res = await ipfs.add(vaultTx.encodeData(), { hashAlg: \"keccak-256\" });\n            console.log(`metadata: ${res.path}`);\n        }\n        // byte(0x19), byte(0x01), domainSeparator, txHash\n        console.log(\"Publish tx hash\");\n        {\n            const res = await ipfs.add(vaultTx.encode(), { hashAlg: \"keccak-256\" });\n            console.log(`metadata: ${res.path}`);\n        }\n        const txHash = \"0x\" + vaultTx.signHash().toString('hex');\n        const dataHash = await this.vaultInstance.generateTxHash(to, value, data, operation, minAvailableGas, nonce, metaHash);\n        if (txHash != dataHash)\n            throw Error(\"Invalid hash generated\");\n        return { vaultHash: txHash, metaHash };\n    }\n    async formatSignature(config, hashProvider, signatures, signer) {\n        let sigs;\n        let signers;\n        if (signatures) {\n            const dataHash = await hashProvider();\n            sigs = signatures.map((sig) => sig.slice(2));\n            let prevIndex = -1;\n            signers = signatures.map((sig) => {\n                const signer = utils.verifyMessage(utils.arrayify(dataHash), sig);\n                const signerIndex = config.signers.indexOf(signer, prevIndex + 1);\n                if (signerIndex <= prevIndex)\n                    throw Error(\"Invalid signer\");\n                prevIndex = signerIndex;\n                return signer;\n            });\n        }\n        else if (config.signers.length == 1) {\n            const singleSigner = await signer.getAddress();\n            if (config.signers.indexOf(singleSigner) < 0)\n                throw Error(\"Signer is not an owner\");\n            sigs = [utils.solidityPack([\"uint256\", \"uint256\", \"bytes1\"], [singleSigner, 0, \"0x01\"]).slice(2)];\n            signers = [singleSigner];\n        }\n        else {\n            throw Error(\"Cannot execute transaction due to missing confirmation\");\n        }\n        return { signaturesString: \"0x\" + sigs.join(\"\"), signers };\n    }\n    async buildExecData(transaction, signatures, signer) {\n        const config = await this.loadConfig();\n        if (!config.nonce.eq(transaction.nonce))\n            throw Error(\"Invalid nonce\");\n        const { signaturesString, signers } = await this.formatSignature(config, () => {\n            return this.vaultInstance.generateTxHash(transaction.to, transaction.value, transaction.data, transaction.operation, transaction.minAvailableGas, transaction.nonce, transaction.metaHash);\n        }, signatures, signer);\n        const validationData = await buildValidationData(config, signaturesString, signers);\n        //console.log(await this.vaultInstance.callStatic.execTransaction(to, value, data, operation, 0, config.nonce, \"0x\", validationData, true))\n        return {\n            wallet: this.address,\n            validationData,\n            transaction\n        };\n    }\n}\nexport class VaultSigner {\n    constructor(vault, signer) {\n        this.vault = vault;\n        this.signer = signer;\n    }\n    async signTx(transaction) {\n        const dataHash = await this.vault.vaultInstance.generateTxHash(transaction.to, transaction.value, transaction.data, transaction.operation, transaction.minAvailableGas, transaction.nonce, transaction.metaHash);\n        return prepareEthSignSignatureForSafe(await this.signer.signMessage(utils.arrayify(dataHash)));\n    }\n    async signTxFromHash(ipfs, txHash) {\n        const vaultTx = await this.vault.fetchTxByHash(ipfs, txHash);\n        return await this.signTx(vaultTx);\n    }\n    async signUpdate(newSigners, newThreshold, nonce) {\n        const config = await this.vault.loadConfig();\n        const dataHash = await this.vault.vaultInstance.generateConfigChangeHash(config.implementation, utils.solidityPack([\"address[]\"], [newSigners]), newThreshold, config.signatureChecker, config.requestGuard, config.fallbackHandler, \"0x\", nonce, \"0x\");\n        return prepareEthSignSignatureForSafe(await this.signer.signMessage(utils.arrayify(dataHash)));\n    }\n}\nexport class VaultExecutor {\n    constructor(vault, executor) {\n        this.vault = vault;\n        this.executor = executor;\n        this.writeVaultInstance = vault.vaultInstance.connect(executor);\n    }\n    async exec(to, value, data, operation, nonce, metaHash, signatures) {\n        const transaction = { to, value: value.toHexString(), data, operation, nonce: nonce.toHexString(), minAvailableGas: \"0x0\", metaHash };\n        const execData = await this.vault.buildExecData(transaction, signatures, this.executor);\n        //console.log(await this.vaultInstance.callStatic.execTransaction(to, value, data, operation, 0, config.nonce, \"0x\", validationData, true))\n        await this.writeVaultInstance.execTransaction(execData.transaction.to, execData.transaction.value, execData.transaction.data, execData.transaction.operation, execData.transaction.minAvailableGas, execData.transaction.nonce, execData.transaction.metaHash, execData.validationData, true);\n    }\n    async update(newSigners, newThreshold, nonce, signatures) {\n        const config = await this.vault.loadConfig();\n        if (!config.nonce.eq(nonce))\n            throw Error(\"Invalid nonce\");\n        const { signaturesString, signers } = await this.vault.formatSignature(config, () => {\n            return this.vault.vaultInstance.generateConfigChangeHash(config.implementation, utils.solidityPack([\"address[]\"], [newSigners]), newThreshold, config.signatureChecker, config.requestGuard, config.fallbackHandler, \"0x\", nonce, \"0x\");\n        }, signatures, this.executor);\n        const validationData = await buildValidationData(config, signaturesString, signers);\n        await this.writeVaultInstance.updateConfig(config.implementation, newSigners, newThreshold, config.signatureChecker, config.requestGuard, config.fallbackHandler, \"0x\", nonce, \"0x\", validationData);\n    }\n}\n//# sourceMappingURL=index.js.map","import { constants, utils } from 'ethers';\nexport const buildProof = async (txSigners, allSigners) => {\n    const ownersCopy = [...allSigners];\n    const indeces = txSigners.map(signer => {\n        const i = ownersCopy.indexOf(signer);\n        ownersCopy[i] = null;\n        return i;\n    });\n    const hashes = [];\n    const nodes = allSigners.map(signer => txSigners.indexOf(signer) < 0 ? utils.solidityKeccak256([\"uint256\"], [signer]) : \"0x0\");\n    let nodesCount = nodes.length;\n    while (nodesCount > 1) {\n        for (let i = 0; i < nodesCount; i += 2) {\n            let left = nodes[i];\n            let right;\n            if (i + 1 < nodesCount) {\n                right = nodes[i + 1];\n            }\n            else {\n                right = utils.solidityKeccak256([\"uint256\"], [\"0x0\"]);\n            }\n            if (left == \"0x0\" && right == \"0x0\") {\n                nodes[Math.floor(i / 2)] = \"0x0\";\n                continue;\n            }\n            if (left == \"0x0\") {\n                hashes.push(right);\n                nodes[Math.floor(i / 2)] = \"0x0\";\n                continue;\n            }\n            if (right == \"0x0\") {\n                hashes.push(left);\n                nodes[Math.floor(i / 2)] = \"0x0\";\n                continue;\n            }\n            nodes[Math.floor(i / 2)] = utils.solidityKeccak256([\"bytes32\", \"bytes32\"], [left, right]);\n        }\n        nodesCount = Math.ceil(nodesCount / 2);\n    }\n    return { indeces, hashes };\n};\nexport const buildValidationData = async (vaultConfig, signatures, signers) => {\n    const { indeces, hashes } = await buildProof(signers, vaultConfig.signers);\n    const validationData = utils.defaultAbiCoder.encode([\"uint256\", \"uint256\", \"address\", \"address\", \"uint256[]\", \"bytes32[]\", \"bytes\"], [vaultConfig.threshold, vaultConfig.signers.length, constants.AddressZero, constants.AddressZero, indeces, hashes, signatures]);\n    return validationData;\n};\n//# sourceMappingURL=proof.js.map","import { config } from 'dotenv'\n\nconfig()\n\nexport const chainNames: { [key: number]: string; } = {\n    1: \"mainnet\",\n    4: \"rinkeby\",\n    100: \"xdai\"\n}\n\nexport const rpcUrl: string = process.env.REACT_APP_RPC_URL!!\n\nexport const chainId: number = parseInt(process.env.REACT_APP_CHAIN_ID!!)\n\nexport const chainName: string = chainNames[chainId]","import { EthHashInfo } from '@gnosis.pm/safe-react-components'\nimport { ThemeColors } from '@gnosis.pm/safe-react-components/dist/theme'\nimport React from 'react'\nimport { chainName } from 'src/utils/config'\n\nconst AccountInfo: React.FC<{ address: string, className?: string, textColor?: ThemeColors }> = ({ address, className, textColor }) => {\n  if (!address) {\n    return null\n  }\n\n  return (\n    <EthHashInfo\n      hash={address}\n      textSize=\"xl\"\n      showCopyBtn\n      showIdenticon\n      showEtherscanBtn\n      shortenHash={4}\n      textColor={textColor || \"white\"}\n      className={className || \"address\"}\n      network={chainName}\n    />\n  )\n}\n\nexport default AccountInfo\n","import { rpcUrl } from \"src/utils/config\"\nimport { Signer, providers } from \"ethers\"\n\nlet localProvider = new providers.JsonRpcProvider({\n    url: rpcUrl\n})\n\nlet localSigner: Signer | undefined = undefined\n\nexport const loadProvider = (): providers.Provider => {\n    return localProvider\n}\n\nexport const setLocalSigner = (signer: Signer) => {\n    localSigner = signer;\n}\n\nexport const clearLocalSigner = () => {\n    localSigner = undefined\n}\n\nexport const loadSigner = (): Signer => {\n    if (!localSigner) localProvider.getSigner()\n    return localSigner!!\n}","import { pullWithKeccak, Vault, VaultTransaction } from \"@rmeissner/stateless-vault-sdk\"\nimport { loadProvider } from \"./ethereumRepository\"\nimport { utils, BigNumber } from 'ethers'\nimport IpfsClient from 'ipfs-http-client';\n\nconst VAULTS_STORAGE_KEY = \"vault_repository.vaults\"\nconst PROPOSAL_STORAGE_KEY_PREFIX = \"vault_repository.proposals.\"\nconst SELECTED_VAULT_STORAGE_KEY = \"vault_repository.selected_vault\"\nconst STORAGE_IPFS_CACHE_PREFIX = \"vault_repository.ipfs_cache.\"\n\ninterface StorageHolder<T> {\n    readonly version: number,\n    readonly value: T\n}\n\nconst ipfs = IpfsClient({\n    host: 'ipfs.infura.io',\n    port: 5001,\n    protocol: 'https'\n});\n\nconst loadVaultStorage = (): { [key: string]: string } => {\n    const stored = localStorage.getItem(VAULTS_STORAGE_KEY)\n    if (!stored) return {}\n    const holder: StorageHolder<{ [key: string]: string }> = JSON.parse(stored)\n    if (holder.version != 0) throw Error(\"Unknown storage version \" + holder.version)\n    return holder.value\n}\n\nconst writeVaultStorage = (vaults: { [key: string]: string }) => {\n    const holder: StorageHolder<{ [key: string]: string }> = {\n        version: 0,\n        value: vaults\n    }\n    localStorage.setItem(VAULTS_STORAGE_KEY, JSON.stringify(holder))\n}\n\nexport const loadLastSelectedVault = async (): Promise<string | undefined> => {\n    const store = localStorage.getItem(SELECTED_VAULT_STORAGE_KEY)\n    if (!store) return undefined\n    const holder: StorageHolder<string> = JSON.parse(store)\n    if (holder.version != 0) throw Error(\"Unknown storage version \" + holder.version)\n    return holder.value\n}\n\nexport const loadVaultName = async (address: string): Promise<string | undefined> => {\n    const vaults = await loadVaultStorage()\n    return vaults[address]\n}\n\nexport const managesVault = async (address: string): Promise<boolean> => {\n    const vaults = await loadVaultStorage()\n    return address in vaults\n}\n\nexport const removeLastSelectedVault = async () => {\n    localStorage.removeItem(SELECTED_VAULT_STORAGE_KEY)\n}\n\nexport const setLastSelectedVault = async (address: string) => {\n    const holder: StorageHolder<string> = {\n        version: 0,\n        value: address\n    }\n    localStorage.setItem(SELECTED_VAULT_STORAGE_KEY, JSON.stringify(holder))\n}\n\nexport const loadVaults = async (): Promise<{ address: string, name: string }[]> => {\n    try {\n        const vaults = loadVaultStorage()\n        return Object.keys(vaults).sort().map((address) => {\n            return {\n                address,\n                name: vaults[address]\n            }\n        })\n    } catch (e) {\n        console.log(e)\n        return []\n    }\n}\n\nexport const setVault = async (address: string, name: string): Promise<void> => {\n    const vaults = loadVaultStorage()\n    vaults[address] = name\n    writeVaultStorage(vaults)\n}\n\nexport const removeVault = async (address: string): Promise<void> => {\n    const vaults = loadVaultStorage()\n    delete vaults[address]\n    writeVaultStorage(vaults)\n}\n\nexport const getVaultInstance = async (address: string): Promise<Vault> => {\n    if (!utils.isAddress(address)) throw Error(\"Invalid Address\")\n    return new Vault(loadProvider(), address)\n}\n\nconst cachedLoader = async (key: string, encoding: string): Promise<string> => {\n    try {\n        const cached = localStorage.getItem(STORAGE_IPFS_CACHE_PREFIX + key)\n        if (cached) return cached\n    } catch (e) {\n        console.error(e)\n    }\n    const value = await pullWithKeccak(ipfs, key, encoding)\n    try {\n        localStorage.setItem(STORAGE_IPFS_CACHE_PREFIX + key, value)\n    } catch (e) {\n        console.error(e)\n    }\n    return value\n}\n\nexport const loadTransactionDetails = async (vault: Vault, vaultHash: string): Promise<VaultTransaction> => {\n    return await vault.fetchTxByHash(ipfs, vaultHash, cachedLoader)\n}\n\nconst loadProposalStorage = (vaultAddress: string): { [key: string]: VaultTransaction } => {\n    const stored = localStorage.getItem(PROPOSAL_STORAGE_KEY_PREFIX + vaultAddress)\n    if (!stored) return {}\n    const holder: StorageHolder<{ [key: string]: VaultTransaction }> = JSON.parse(stored)\n    if (holder.version != 0) throw Error(\"Unknown storage version \" + holder.version)\n    return holder.value\n}\n\nconst writeProposalStorage = (vaultAddress: string, vaults: { [key: string]: VaultTransaction }) => {\n    const holder: StorageHolder<{ [key: string]: VaultTransaction }> = {\n        version: 0,\n        value: vaults\n    }\n    localStorage.setItem(PROPOSAL_STORAGE_KEY_PREFIX + vaultAddress, JSON.stringify(holder))\n}\n\nexport const loadTransactionProposals = async (vault: Vault): Promise<{ vaultHash: string, transaction: VaultTransaction }[]> => {\n    const proposals = loadProposalStorage(vault.address)\n    return Object.entries(proposals)\n        .map(([vaultHash, transaction]) => { return { vaultHash, transaction } })\n        .sort((left, right) => BigNumber.from(left.transaction.nonce).sub(BigNumber.from(right.transaction.nonce)).toNumber())\n}\n\nexport const removeTransactionProposals = async (vault: Vault, vaultHashes: string[]): Promise<void> => {\n    const proposals = loadProposalStorage(vault.address)\n    for (let vaultHash of vaultHashes) {\n        delete proposals[vaultHash]\n    }\n    writeProposalStorage(vault.address, proposals)\n}\n\nexport const addTransactionProposal = async (vault: Vault, transaction: VaultTransaction): Promise<string> => {\n    console.log(ipfs)\n    const { vaultHash, metaHash } = await vault.publishTx(\n        ipfs,\n        transaction.to,\n        BigNumber.from(transaction.value),\n        transaction.data,\n        transaction.operation,\n        BigNumber.from(transaction.nonce),\n        transaction.meta\n    )\n    transaction.metaHash = metaHash\n    const proposals = loadProposalStorage(vault.address)\n    proposals[vaultHash] = transaction\n    writeProposalStorage(vault.address, proposals)\n    return vaultHash\n}","import * as React from 'react'\nimport { Vault, VaultAction, VaultTransaction } from '@rmeissner/stateless-vault-sdk';\nimport { createStyles, WithStyles, withStyles, Box, List, ListItem, Typography } from '@material-ui/core';\nimport { Link } from 'react-router-dom';\nimport { loadTransactionProposals, removeTransactionProposals } from 'src/logic/vaultRepository';\n\nconst styles = createStyles({\n    list: {\n    },\n    item: {\n        display: 'block'\n    }\n})\n\ninterface Props extends WithStyles<typeof styles> {\n    vault: Vault\n}\n\nconst VaultTransactions: React.FC<Props> = ({ vault, classes }) => {\n    const [transactions, setTransactions] = React.useState<VaultAction[]>([])\n    const [proposals, setProposals] = React.useState<{vaultHash: string, transaction: VaultTransaction}[]>([])\n    const loadItems = React.useCallback(async () => {\n        try {\n            const transactions = await vault.loadTransactions()\n            await removeTransactionProposals(\n                vault, transactions.map((tx) => (tx.action === \"executed_transaction\") ? tx.vaultHash : \"\").filter((val) => val !== \"\")\n            )\n            setProposals(await loadTransactionProposals(vault))\n            setTransactions(transactions)\n        } catch (e) {\n            console.log(`Could not load transactions`)\n            console.error(e)\n        }\n    }, [vault, setTransactions, setProposals])\n    React.useEffect(() => {\n        setProposals([])\n        setTransactions([])\n        loadItems()\n    }, [vault.address])\n    const listItems = transactions.map((tx) => {\n        switch (tx.action) {\n            case \"config_update\":\n                return (<ListItem className={classes.item}>\n                    <Box>Config Update</Box>\n                    <Box textOverflow=\"ellipsis\" overflow=\"hidden\">{tx.txHash}</Box>\n                </ListItem>);\n            case \"executed_transaction\":\n                if (tx.success) {\n                    return (<Link to={location => `${location.pathname}/${tx.vaultHash}`}>\n                        <ListItem className={classes.item}>\n                            <Box>Tx success (nonce {tx.nonce.toString()})</Box>\n                            <Box textOverflow=\"ellipsis\" overflow=\"hidden\">{tx.ethereumHash}</Box>\n                        </ListItem>\n                    </Link>);\n                } else {\n                    return (<Link to={location => `${location.pathname}/${tx.vaultHash}`}>\n                        <ListItem className={classes.item}>\n                            <Box>Tx failure (nonce {tx.nonce.toString()})</Box>\n                            <Box textOverflow=\"ellipsis\" overflow=\"hidden\">{tx.ethereumHash}</Box>\n                        </ListItem>\n                    </Link >);\n                }\n        }\n    })\n    const proposalItems = proposals.map((proposal) => (\n        <Link to={location => `${location.pathname}/${proposal.vaultHash}`}>\n            <ListItem className={classes.item}><Box>Tx propsal (nonce {proposal.transaction.nonce})</Box></ListItem>\n        </Link>\n    ))\n    console.log({proposalItems})\n    return (proposalItems.length + transactions.length) > 0 ? (\n        <List className={classes.list}>\n            {\n                proposalItems.length > 0 && (\n                    <>\n                        <ListItem className={classes.item}><Typography>Proposals</Typography></ListItem>\n                        { proposalItems}\n                    </>\n                )\n            }\n            {\n                listItems.length > 0 && (\n                    <>\n                        <ListItem className={classes.item}><Typography>History</Typography></ListItem>\n                        { listItems}\n                    </>\n                )\n            }\n        </List>\n    ) : (\n            <p>No Transactions yet</p>\n        )\n}\n\nexport default withStyles(styles)(VaultTransactions)","import * as React from 'react'\nimport { Vault, VaultTransaction } from '@rmeissner/stateless-vault-sdk';\nimport { useHistory, useParams } from \"react-router-dom\";\nimport WalletInfo from '../../WalletInfo'\nimport { createStyles, WithStyles, withStyles, Box, Typography } from '@material-ui/core';\nimport { loadTransactionDetails } from 'src/logic/vaultRepository';\nimport { utils } from 'ethers';\n\nconst styles = createStyles({\n    details: {\n        flex: 1\n    },\n    data: {\n        overflowWrap: 'anywhere',\n        maxWidth: '100vw'\n    },\n    address: {\n        display: 'flex',\n        justifyContent: 'center',\n        maxWidth: '100vw'\n    }\n})\n\ninterface Props extends WithStyles<typeof styles> {\n    vault: Vault\n}\n\ninterface Path {\n    vaultHash: string\n}\n\nconst VaultTransactionDetails: React.FC<Props> = ({ vault, classes }) => {\n    console.log(\"Load Transaction\")\n    const history = useHistory()\n    const { vaultHash } = useParams<Path>()\n    console.log(useParams<any>())\n    const [details, setDetails] = React.useState<VaultTransaction | undefined>(undefined)\n    const loadDetails = React.useCallback(async () => {\n        try {\n            setDetails(await loadTransactionDetails(vault, vaultHash))\n        } catch (e) {\n            console.log(`Could not load transactions`)\n            console.error(e)\n            history.goBack()\n        }\n    }, [vault, vaultHash, setDetails])\n    console.log({ vaultHash })\n    React.useEffect(() => {\n        loadDetails()\n    }, [])\n    return details ? (\n        <Box className={classes.details}>\n            <p>Nonce</p>\n            <Typography>{details.nonce}</Typography>\n            <p>To</p>\n            <Box className={classes.address}><WalletInfo address={details.to} textColor=\"text\" /></Box>\n            <p>Value</p>\n            <Typography>{utils.formatEther(details.value)} ETH</Typography>\n            <p>Data</p>\n            <Typography className={classes.data}>{details.data}</Typography>\n            <p>Meta</p>\n            <Typography className={classes.data}>{details.meta}</Typography>\n            <p>Operation</p>\n            <Typography>{details.operation}</Typography>\n            <p>Min available gas</p>\n            <Typography>{details.minAvailableGas}</Typography>\n        </Box>\n    ) : (\n            <p>Loading details</p>\n        )\n}\n\nexport default withStyles(styles)(VaultTransactionDetails)","import * as React from 'react'\nimport { Button, createStyles, WithStyles, withStyles, TextField, Dialog, DialogContent, DialogTitle, DialogContentText, DialogActions } from '@material-ui/core'\nimport { useHistory } from 'react-router'\nimport { setVault, setLastSelectedVault, managesVault } from 'src/logic/vaultRepository'\nimport { utils } from 'ethers'\n\nconst styles = createStyles({\n    remove: {\n        margin: '16px'\n    },\n    item: {\n        flex: 1\n    }\n})\n\ninterface Props extends WithStyles<typeof styles> {\n    open: boolean,\n    onClose: () => void\n}\n\nconst AddVaultDialog: React.FC<Props> = ({ open, onClose }) => {\n    const history = useHistory()\n    const [vaultName, setVaultName] = React.useState(\"\")\n    const [vaultAddress, setVaultAddress] = React.useState(\"\")\n    const [inputError, setInputError] = React.useState<string | undefined>()\n    const addVault = React.useCallback(async () => {\n        try {\n            const cleanAddress = utils.getAddress(vaultAddress)\n            if (await managesVault(cleanAddress)) {\n                setInputError(\"Vault already exists in app\")\n                return\n            }\n            await setVault(cleanAddress, vaultName)\n            await setLastSelectedVault(cleanAddress)\n            onClose()\n            history.push(`/`)\n        } catch (e) {\n            console.error(e)\n            setInputError(\"Invalid vault address\")\n        }\n    }, [setInputError, vaultAddress, vaultName, history])\n    return (\n        <Dialog\n            open={open}\n            onClose={onClose}\n            scroll=\"paper\"\n            aria-labelledby=\"scroll-dialog-title\"\n            aria-describedby=\"scroll-dialog-description\">\n            <DialogTitle id=\"scroll-dialog-title\">Add a Vault</DialogTitle>\n            <DialogContent dividers={true}>\n                <DialogContentText\n                    id=\"scroll-dialog-description\"\n                    tabIndex={-1}\n                >\n                    <TextField\n                        label=\"Vault name\"\n                        onChange={(e) => {\n                            setVaultName(e.target.value)\n                        }}>\n                        {vaultName}\n                    </TextField>\n                    <TextField\n                        label=\"Vault address\"\n                        onChange={(e) => {\n                            setVaultAddress(e.target.value)\n                            setInputError(undefined)\n                        }}\n                        error={inputError !== undefined}\n                        helperText={inputError}>\n                        {vaultAddress}\n                    </TextField>\n                </DialogContentText>\n            </DialogContent>\n            <DialogActions>\n                <Button onClick={onClose} color=\"default\">\n                    Cancel\n                </Button>\n                <Button onClick={addVault} color=\"primary\">\n                    Add\n                </Button>\n            </DialogActions>\n        </Dialog>\n    )\n}\n\nexport default withStyles(styles)(AddVaultDialog)","import * as React from 'react'\nimport { Vault, VaultConfig } from '@rmeissner/stateless-vault-sdk'\nimport { Box, createStyles, WithStyles, withStyles, List, ListItem } from '@material-ui/core'\nimport WalletInfo from '../../WalletInfo'\n\nconst styles = createStyles({\n    list: {\n    },\n    content: {\n    },\n    item: {\n        display: 'flex',\n        justifyContent: 'center',\n        maxWidth: '100vw'\n    }\n})\n\ninterface Props extends WithStyles<typeof styles> {\n    vault: Vault\n}\n\nconst VaultSettings: React.FC<Props> = ({ vault, classes }) => {\n    const [configuration, setConfiguration] = React.useState<VaultConfig | undefined>(undefined)\n    const loadConfig = React.useCallback(async () => {\n        try {\n            setConfiguration(await vault.loadConfig())\n        } catch (e) {\n            console.log(`Could not load transactions`)\n            console.error(e)\n        }\n    }, [vault, setConfiguration])\n    React.useEffect(() => {\n        loadConfig()\n    }, [])\n    return configuration ? (\n        <div className={classes.content}>\n            <p>Threshold</p>\n            <Box>{configuration.threshold.toString()}</Box>\n            <p>Nonce</p>\n            <Box>{configuration.nonce.toString()}</Box>\n            <p>Signers</p>\n            <List className={classes.list}>\n                {configuration.signers.map((signer) => {\n                    return (\n                        <ListItem className={classes.item}><WalletInfo address={signer} textColor=\"text\" /></ListItem>\n                    )\n                })}\n            </List>\n            <p>Implementation</p>\n            <Box className={classes.item}><WalletInfo address={configuration.implementation} textColor=\"text\" /></Box>\n        </div>\n    ) : (\n            <p>Loading config</p>\n        )\n}\n\nexport default withStyles(styles)(VaultSettings)","import * as React from 'react'\nimport { Box, Button, createStyles, WithStyles, withStyles, List, ListItem, Dialog, DialogContent, DialogTitle, DialogContentText, DialogActions } from '@material-ui/core'\nimport { useHistory } from 'react-router'\nimport { loadLastSelectedVault, loadVaults, removeVault, removeLastSelectedVault, setLastSelectedVault } from 'src/logic/vaultRepository'\nimport AccountInfo from 'src/components/WalletInfo'\nimport { Delete } from '@material-ui/icons';\n\nconst styles = createStyles({\n    remove: {\n        margin: '16px'\n    },\n    item: {\n        flex: 1\n    }\n})\n\ninterface Props extends WithStyles<typeof styles> {\n    open: boolean,\n    onClose: () => void\n    onAdd?: () => void\n}\n\nconst VaultSelectionDialog: React.FC<Props> = ({ classes, open, onClose, onAdd }) => {\n    const history = useHistory()\n    const [vaults, setVaults] = React.useState<{ address: string, name: string }[]>([])\n    const select = React.useCallback(async (address: string) => {\n        try {\n            await setLastSelectedVault(address)\n            history.push('/')\n        } catch (e) {\n            console.error(e)\n        }\n    }, [history])\n    const remove = React.useCallback(async (address: string) => {\n        try {\n            const lastVault = await loadLastSelectedVault()\n            if (lastVault === address) {\n                await removeLastSelectedVault()\n            }\n            await removeVault(address)\n            history.push('/')\n        } catch (e) {\n            console.error(e)\n        }\n    }, [history])\n    React.useEffect(() => {\n        console.log(\"init\")\n        const init = async () => {\n            try {\n                setVaults(await loadVaults())\n            } catch (e) {\n                onClose()\n            }\n        }\n        init()\n    }, [open])\n    return (\n        <Dialog\n            open={open}\n            onClose={onClose}\n            scroll=\"paper\"\n            aria-labelledby=\"scroll-dialog-title\"\n            aria-describedby=\"scroll-dialog-description\">\n            <DialogTitle id=\"scroll-dialog-title\">Select a Vault</DialogTitle>\n            <DialogContent dividers={true}>\n                <DialogContentText\n                    id=\"scroll-dialog-description\"\n                    tabIndex={-1}\n                >\n                    <List>\n                        {vaults.map((vault) => (\n                            <ListItem onClick={() => select(vault.address)}>\n                                <Box className={classes.item}>\n                                    {vault.name}\n                                    <AccountInfo address={vault.address} textColor=\"text\" />\n                                </Box>\n                                <Button className={classes.remove} color=\"secondary\" onClick={() => remove(vault.address)}><Delete color=\"secondary\" /></Button>\n                            </ListItem>\n                        ))}\n                        {onAdd && (\n                            <ListItem>\n                                <Button onClick={() => { onAdd(); onClose() }} color=\"default\">Add vault</Button>\n                            </ListItem>\n                        )}\n                    </List>\n                </DialogContentText>\n            </DialogContent>\n            <DialogActions>\n                <Button onClick={onClose} color=\"primary\">\n                    Cancel\n                </Button>\n            </DialogActions>\n        </Dialog>\n    )\n}\n\nexport default withStyles(styles)(VaultSelectionDialog)","import {\n    InterfaceMessageIds,\n    InterfaceMessageToPayload,\n    SDK_MESSAGES,\n    SDKMessageIds,\n    SDKMessageToPayload,\n    RequestId,\n    Transaction,\n} from '@gnosis.pm/safe-apps-sdk'\n\nexport type InterfaceMessageProps<T extends InterfaceMessageIds> = {\n    messageId: T\n    data: InterfaceMessageToPayload[T]\n}\n\nexport type ReturnType = {\n    sendMessageToIframe: <T extends InterfaceMessageIds>(message: InterfaceMessageProps<T>, requestId?: RequestId) => void\n}\n\nexport interface CustomMessageEvent extends MessageEvent {\n    data: {\n        requestId: RequestId\n        messageId: SDKMessageIds\n        data: SDKMessageToPayload[SDKMessageIds]\n    }\n}\n\nexport interface InterfaceMessageRequest extends InterfaceMessageProps<InterfaceMessageIds> {\n    requestId: number | string\n}\n\nexport const sendMessageToIframe = <T extends InterfaceMessageIds>(\n    iframe: HTMLIFrameElement,\n    appUrl: string,\n    message: InterfaceMessageProps<T>,\n    requestId?: RequestId\n) => {\n    const requestWithMessage = {\n        ...message,\n        requestId: requestId || Math.trunc(window.performance.now()),\n    }\n\n    iframe?.contentWindow?.postMessage(requestWithMessage, appUrl)\n}\n\nexport interface MessageHandlers {\n    onSDKIntitalized: () => void,\n    onTransactionProposal: (transactions: Transaction[], requestId: RequestId) => void\n}\n\nconst handleIframeMessage = (\n    messageId: SDKMessageIds,\n    messagePayload: SDKMessageToPayload[typeof messageId],\n    requestId: RequestId,\n    handler: MessageHandlers\n): void => {\n    if (!messageId) {\n        console.error('ThirdPartyApp: A message was received without message id.')\n        return\n    }\n\n    switch (messageId) {\n        // typescript doesn't narrow type in switch/case statements\n        // issue: https://github.com/microsoft/TypeScript/issues/20375\n        // possible solution: https://stackoverflow.com/a/43879897/7820085\n        case SDK_MESSAGES.SEND_TRANSACTIONS: {\n            if (messagePayload) {\n                handler.onTransactionProposal(\n                    messagePayload as SDKMessageToPayload[typeof SDK_MESSAGES.SEND_TRANSACTIONS],\n                    requestId,\n                )\n            }\n            break\n        }\n\n        case SDK_MESSAGES.SEND_TRANSACTIONS_V2: {\n            // TODO: handle payload params\n            const payload = messagePayload as SDKMessageToPayload[typeof SDK_MESSAGES.SEND_TRANSACTIONS_V2]\n            if (payload) {\n                handler.onTransactionProposal(payload.txs, requestId)\n            }\n            break\n        }\n\n        case SDK_MESSAGES.SAFE_APP_SDK_INITIALIZED: {\n            handler.onSDKIntitalized()\n            break\n        }\n        default: {\n            console.error(`ThirdPartyApp: A message was received with an unknown message id ${messageId}.`)\n            break\n        }\n    }\n}\n\nexport const iframeMessageHandler = (appUrl: string, handler: MessageHandlers): ((message: CustomMessageEvent) => void) => async (message: CustomMessageEvent) => {\n    if (message.origin === window.origin) {\n        return\n    }\n    if (!appUrl.includes(message.origin)) {\n        console.error(`ThirdPartyApp: A message was received from an unknown origin ${message.origin}`)\n        return\n    }\n    handleIframeMessage(message.data.messageId, message.data.data, message.data.requestId, handler)\n}","import * as React from 'react'\nimport { Vault, VaultTransaction } from '@rmeissner/stateless-vault-sdk';\nimport { addTransactionProposal } from 'src/logic/vaultRepository';\nimport { Box, Button, Typography, createStyles, withStyles, WithStyles, List, ListItem, Dialog, DialogContent, DialogTitle, DialogActions } from '@material-ui/core'\nimport { RequestId, Transaction } from '@gnosis.pm/safe-apps-sdk'\nimport AccountInfo from 'src/components/WalletInfo';\nimport { utils } from 'ethers';\n\nconst styles = createStyles({\n    item: {\n        display: 'block'\n    }\n})\n\ninterface Props extends WithStyles<typeof styles> {\n    open: boolean,\n    vault: Vault,\n    transactions: Transaction[],\n    requestId: RequestId,\n    app?: string,\n    onConfirm: (requestId: RequestId, vaultHash: string) => void,\n    onReject: (requestId: RequestId, message: string) => void\n}\n\nconst buildMultiSend = async (transactions: Transaction[], nonce: string, meta: any | undefined): Promise<VaultTransaction> => {\n    const metaString = meta ? JSON.stringify(meta) : undefined\n    if (transactions.length == 1) return {\n        to: transactions[0].to,\n        value: transactions[0].value,\n        data: transactions[0].data,\n        operation: 0,\n        minAvailableGas: \"0x00\",\n        nonce,\n        metaHash: \"\", // Will be set by repo,\n        meta: metaString\n    }\n    return {\n        to: transactions[0].to,\n        value: transactions[0].value,\n        data: transactions[0].data,\n        operation: 0,\n        minAvailableGas: \"0x00\",\n        nonce,\n        metaHash: \"\", // Will be set by repo,\n        meta: metaString\n    }\n}\n\nconst TransactionProposalDialog: React.FC<Props> = ({ classes, open, vault, transactions, requestId, app, onConfirm, onReject }) => {\n    const proposeTx = React.useCallback(async () => {\n        try {\n            const config = await vault.loadConfig()\n            const meta = {\n                app: app\n            }\n            const transaction = await buildMultiSend(transactions, config.nonce.toHexString(), meta)\n            await addTransactionProposal(vault, transaction)\n            onConfirm(requestId, \"\")\n        } catch (e) {\n            console.error(e)\n        }\n    }, [vault, app, requestId, transactions, onConfirm])\n    const rejectTx = React.useCallback(async () => {\n        onReject(requestId, \"User rejected transaction\")\n    }, [requestId, onReject])\n    return (\n        <Dialog\n            open={open}\n            onClose={rejectTx}\n            scroll=\"paper\"\n            aria-labelledby=\"scroll-dialog-title\"\n            aria-describedby=\"scroll-dialog-description\">\n            <DialogTitle id=\"scroll-dialog-title\">Confirm Transaction</DialogTitle>\n            <DialogContent dividers={true}>\n                <List>\n                    {transactions.map((transaction) => (\n                        <ListItem className={classes.item}>\n                            <Box><AccountInfo address={transaction.to} textColor=\"text\" /></Box>\n                            <Typography>{utils.formatEther(transaction.value)} ETH</Typography>\n                            <Box textOverflow=\"ellipsis\" overflow=\"hidden\">{transaction.data}</Box>\n                        </ListItem>\n                    ))}\n                </List>\n            </DialogContent>\n            <DialogActions>\n                <Button onClick={rejectTx} color=\"default\">\n                    Cancel\n                </Button>\n                <Button onClick={proposeTx} color=\"primary\">\n                    Confirm\n                </Button>\n            </DialogActions>\n        </Dialog>\n    )\n}\n\nexport default withStyles(styles)(TransactionProposalDialog)","import * as React from 'react'\nimport { Vault } from '@rmeissner/stateless-vault-sdk';\nimport { createStyles, WithStyles, withStyles } from '@material-ui/core';\nimport { iframeMessageHandler, sendMessageToIframe, MessageHandlers } from './messaging';\nimport { INTERFACE_MESSAGES, LowercaseNetworks, RequestId, Transaction } from '@gnosis.pm/safe-apps-sdk'\nimport { chainName } from 'src/utils/config';\nimport TransactionProposalDialog from './TransactionProposalDialog';\n\nconst styles = createStyles({\n    appContainer: {\n        border: 0,\n        frameborder: 0,\n        width: '100%',\n        height: '100%'\n    }\n})\n\ninterface Props extends WithStyles<typeof styles> {\n    vault: Vault\n}\n\ninterface ProposalParams {\n    transactions: Transaction[]\n    requestId: RequestId\n}\n\nconst VaultApps: React.FC<Props> = ({ vault, classes }) => {\n    const [proposalParams, setProposalParams] = React.useState<ProposalParams | undefined>(undefined)\n    const appUrl = \"https://apps.gnosis-safe.io/tx-builder\"\n    const appFrame = React.useRef<HTMLIFrameElement>(null)\n    const handlers: MessageHandlers = React.useMemo(() => {\n        return {\n            onSDKIntitalized: () => {\n                const iframe = appFrame.current\n                if (!iframe) return\n                sendMessageToIframe(\n                    iframe,\n                    appUrl,\n                    {\n                        messageId: INTERFACE_MESSAGES.ON_SAFE_INFO,\n                        data: {\n                            safeAddress: vault.address,\n                            network: chainName as LowercaseNetworks,\n                            ethBalance: \"0\",\n                        },\n                    }\n                )\n            },\n            onTransactionProposal: (transactions, requestId) => {\n                if (transactions.length == 0) return\n                setProposalParams({ transactions, requestId })\n            }\n        }\n    }, [vault, appFrame, appUrl, setProposalParams])\n\n    const handleTransactionConfirmation = React.useCallback(async (requestId: RequestId, vaultHash: string) => {\n        const iframe = appFrame.current\n        if (!iframe) return\n        sendMessageToIframe(\n            iframe,\n            appUrl,\n            {\n                messageId: INTERFACE_MESSAGES.TRANSACTION_CONFIRMED,\n                data: {\n                    safeTxHash: vaultHash\n                },\n            },\n            requestId\n        )\n        setProposalParams(undefined)\n    }, [appFrame, appUrl, setProposalParams])\n\n    const handleTransactionRejection = React.useCallback(async (requestId: RequestId, message: string) => {\n        const iframe = appFrame.current\n        if (!iframe) return\n        sendMessageToIframe(\n            iframe,\n            appUrl,\n            {\n                messageId: INTERFACE_MESSAGES.TRANSACTION_REJECTED,\n                data: { message },\n            },\n            requestId\n        )\n        setProposalParams(undefined)\n    }, [appFrame, appUrl, setProposalParams])\n\n    const loaded = React.useCallback(async () => {\n        handlers.onSDKIntitalized()\n    }, [handlers])\n\n    React.useEffect(() => {\n        const messageHandler = iframeMessageHandler(appUrl, handlers)\n        window.addEventListener('message', messageHandler)\n        return () => {\n            window.removeEventListener('message', messageHandler)\n        }\n    }, [appFrame, appUrl, handlers])\n\n    return (\n        <>\n            <iframe ref={appFrame} onLoad={loaded} src={appUrl} className={classes.appContainer} />\n            { proposalParams && (<TransactionProposalDialog\n                open={true}\n                vault={vault}\n                app={appUrl}\n                transactions={proposalParams.transactions}\n                requestId={proposalParams.requestId}\n                onReject={handleTransactionRejection}\n                onConfirm={handleTransactionConfirmation} />\n            )}\n        </>\n    )\n}\n\nexport default withStyles(styles)(VaultApps)","import * as React from 'react'\nimport WalletInfo from 'src/components/WalletInfo'\nimport { Vault } from '@rmeissner/stateless-vault-sdk';\nimport { Redirect, Route, Switch, useHistory, useParams, useRouteMatch } from \"react-router-dom\";\nimport { AppBar, BottomNavigation, BottomNavigationAction, Container, createStyles, Toolbar, WithStyles, withStyles } from '@material-ui/core';\nimport { Timeline, Settings, ArrowDropDown, Apps } from '@material-ui/icons';\nimport { getVaultInstance } from 'src/logic/vaultRepository';\nimport styled from 'styled-components'\nimport VaultTransactions from './transactions/VaultTransactions';\nimport VaultTransactionDetails from './transactions/VaultTransactionDetails';\nimport AddVaultDialog from './settings/AddVaultDialog';\nimport VaultSettings from './settings/VaultSettings';\nimport VaultSelectionDialog from './settings/VaultSelectionDialog';\nimport VaultApps from './apps/VaultApps';\n\nconst styles = createStyles({\n    title: {\n        flex: 1\n    },\n    toolbar: {\n        maxWidth: '100vw',\n        background: '#ffffff'\n    },\n    content: {\n        paddingBottom: '64px',\n        flex: \"1 1 auto\",\n        maxWidth: '100vw'\n    },\n    navigation: {\n        height: '64px',\n        position: 'fixed',\n        bottom: 0,\n        width: '100vw'\n    }\n})\n\nconst VaultHomeContainer = styled.main`\n  display: flex;\n  flex-direction: column;\n  align-items: top;\n  text-align: center;\n  flex-grow: 1;\n  width: 100vw;\n  height: 100vh;\n`\n\ninterface Active {\n    address: string,\n    instance: Vault\n}\n\ninterface Path {\n    vaultAddress: string\n}\n\nconst VaultHome: React.FC<WithStyles<typeof styles>> = ({ classes }) => {\n    const match = useRouteMatch()\n    const [active, setActive] = React.useState<Active | undefined>(undefined)\n    const [showVaultSelection, setShowVaultSelection] = React.useState(false)\n    const [showAddVault, setShowAddVault] = React.useState(false)\n    const history = useHistory()\n    const { vaultAddress } = useParams<Path>()\n    React.useEffect(() => {\n        const loadActive = async () => {\n            try {\n                const instance = await getVaultInstance(vaultAddress)\n                setActive({\n                    address: vaultAddress,\n                    instance\n                })\n            } catch (e) {\n                console.log(`Could not load Vault ${vaultAddress}`)\n                console.error(e)\n                history.push(`/`)\n            }\n        }\n        loadActive()\n    }, [vaultAddress, setActive])\n    if (!active) return (<>Loading</>)\n    return (\n        <VaultHomeContainer>\n            <AppBar position=\"fixed\">\n                <Toolbar className={classes.toolbar}>\n                    <WalletInfo address={active.address!} className={classes.title} textColor=\"text\" />\n                    <ArrowDropDown color=\"action\" onClick={() => setShowVaultSelection(true)} />\n                </Toolbar>\n            </AppBar>\n            <Toolbar />\n            <Container className={classes.content}>\n                <Switch>\n                    <Route path={`${match.path}/transactions/:vaultHash`}>\n                        <VaultTransactionDetails vault={active.instance} />\n                    </Route>\n                    <Route path={`${match.path}/transactions`}>\n                        <VaultTransactions vault={active.instance} />\n                    </Route>\n                    <Route path={`${match.path}/config`}>\n                        <VaultSettings vault={active.instance} />\n                    </Route>\n                    <Route path={`${match.path}/apps`}>\n                        <VaultApps vault={active.instance} />\n                    </Route>\n                    <Route path=\"*\">\n                        <Redirect to={`${match.url}/transactions`} />\n                    </Route>\n                </Switch>\n            </Container>\n            <BottomNavigation\n                className={classes.navigation}\n                onChange={(_, newValue) => {\n                    switch (newValue) {\n                        case 1:\n                            history.push(`${match.url}/apps`)\n                            break;\n                        case 2:\n                            history.push(`${match.url}/config`)\n                            break;\n                        default:\n                            history.push(`${match.url}/transactions`)\n                            break;\n                    }\n                }}\n                showLabels\n            >\n                <BottomNavigationAction label=\"Transactions\" icon={<Timeline />} />\n                <BottomNavigationAction label=\"Apps\" icon={<Apps />} />\n                <BottomNavigationAction label=\"Settings\" icon={<Settings />} />\n            </BottomNavigation>\n            <VaultSelectionDialog open={showVaultSelection} onClose={() => setShowVaultSelection(false)} onAdd={() => setShowAddVault(true)} />\n            <AddVaultDialog open={showAddVault} onClose={() => setShowAddVault(false)} />\n        </VaultHomeContainer>\n    )\n}\n\nexport default withStyles(styles)(VaultHome)","export default __webpack_public_path__ + \"static/media/yacate-logo.30ab8735.svg\";","export const undefinedOnError = async<T>(func: Promise<T>): Promise<T | undefined> => {\n    try {\n        return await func\n    } catch (e) {\n        console.error(e)\n        return undefined\n    }\n}","import AppLogo from 'src/assets/icons/yacate-logo.svg'\nimport * as React from 'react'\nimport styled from 'styled-components'\nimport { TextField } from '@material-ui/core'\nimport { utils } from 'ethers'\nimport { Button } from '@gnosis.pm/safe-react-components'\nimport { loadLastSelectedVault, loadVaults, setLastSelectedVault, setVault } from 'src/logic/vaultRepository'\nimport { useHistory } from 'react-router'\nimport { undefinedOnError } from 'src/utils/general'\n\nconst OnboardingContainer = styled.main`\n  display: flex;\n  flex-direction: column;\n  flex-grow: 1;\n  align-items: center;\n  text-align: center;\n`\n\nconst SHeading = styled.h1`\n@media screen and (max-width: 768px) {\n  font-size: 1.2em;\n}\n`\n\nconst Welcome: React.FC = () => {\n  const history = useHistory()\n  const [loading, setLoading] = React.useState(true)\n  const [vaultName, setVaultName] = React.useState(\"\")\n  const [vaultAddress, setVaultAddress] = React.useState(\"\")\n  const [inputError, setInputError] = React.useState<string | undefined>()\n  const addVault = React.useCallback(async () => {\n    try {\n      const cleanAddress = utils.getAddress(vaultAddress)\n      await setVault(cleanAddress, vaultName)\n      await setLastSelectedVault(cleanAddress)\n      history.replace(`/${cleanAddress}`)\n    } catch (e) {\n      console.error(e)\n      setInputError(\"Invalid vault address\")\n    }\n  }, [setInputError, vaultAddress, vaultName, history])\n\n  const loadSelected = React.useCallback(async () => {\n    setLoading(true)\n    let selectedVault = await undefinedOnError(loadLastSelectedVault())\n    if (!selectedVault) {\n      const vaults = await loadVaults()\n      if (vaults.length > 0) {\n        selectedVault = vaults[0].address\n        await setLastSelectedVault(selectedVault)\n      }\n    }\n    if (selectedVault) {\n      history.replace(`/${selectedVault}`)\n    }\n    setLoading(false)\n  }, [history, setLoading])\n\n  React.useEffect(() => {\n    loadSelected()\n  }, [loadSelected])\n\n  if (loading) return (\n    <OnboardingContainer>\n      <img src={AppLogo} alt=\"App Logo\" width=\"100\"></img>\n      <SHeading>Yacate - A smart wallet based on the Stateless Vault</SHeading>\n      <p>Loading</p>\n    </OnboardingContainer>\n  )\n  return (\n    <OnboardingContainer>\n      <img src={AppLogo} alt=\"App Logo\" width=\"100\"></img>\n      <SHeading>Yacate - A smart wallet based on the Stateless Vault</SHeading>\n      <p>Start by adding a Vault</p>\n      <TextField\n        label=\"Vault name\"\n        onChange={(e) => {\n          setVaultName(e.target.value)\n        }}>\n        {vaultName}\n      </TextField>\n      <TextField\n        label=\"Vault address\"\n        onChange={(e) => {\n          setVaultAddress(e.target.value)\n          setInputError(undefined)\n        }}\n        error={inputError !== undefined}\n        helperText={inputError}>\n        {vaultAddress}\n      </TextField>\n      <Button size=\"lg\" color=\"primary\" onClick={addVault}>Add Vault</Button>\n    </OnboardingContainer>\n  )\n}\n\nexport default Welcome","import React from 'react'\nimport { Route, Switch, HashRouter as Router } from \"react-router-dom\"\nimport VaultHome from './vault/VaultHome'\nimport Welcome from './onboarding/Welcome'\n\n\nconst App: React.FC = () => {\n  return (\n    <Router>\n      <Switch>\n        <Route path=\"/:vaultAddress\">\n          <VaultHome />\n        </Route>\n        <Route path=\"/\">\n          <Welcome />\n        </Route>\n      </Switch>\n    </Router>\n  )\n}\n\nexport default App\n","import avertaBoldFont from '@gnosis.pm/safe-react-components/dist/fonts/averta-bold.woff2'\nimport avertaFont from '@gnosis.pm/safe-react-components/dist/fonts/averta-normal.woff2'\nimport { createGlobalStyle } from 'styled-components'\nimport { normalize } from 'styled-normalize'\n\nconst GlobalStyles = createGlobalStyle`\n  ${normalize}\n\n  @font-face {\n    font-family: 'Averta';\n    font-display: swap;\n    src: local('Averta'), local('Averta Bold'),\n    url(${avertaFont}) format('woff2'),\n    url(${avertaBoldFont}) format('woff');\n  }\n\n  body {\n    font-family: 'Averta', sans-serif;\n    margin: 0;\n    padding: 0;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    width: 100vw;\n    height: 100vh;\n    background: #fefefe;\n  }\n\n  .web3connect-connect-button {\n    background-color: #008c73 !important;\n  }\n\n  .walletconnect-qrcode__base {\n    left: 0;\n  }\n\n  a {\n    color: #008c73;\n  }\n\n  .address p {\n    font-family: 'Roboto', monospace;\n  }\n`\n\nexport default GlobalStyles\n","import { theme } from '@gnosis.pm/safe-react-components'\nimport React from 'react'\nimport App from 'src/components/App'\nimport GlobalStyles from 'src/styles/global'\nimport { ThemeProvider } from 'styled-components'\n\nconst Root: React.FC = () => (\n  <React.StrictMode>\n    <ThemeProvider theme={theme}>\n      <GlobalStyles />\n      <App />\n    </ThemeProvider>\n  </React.StrictMode>\n)\n\nexport default Root\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n)\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void\n  onUpdate?: (registration: ServiceWorkerRegistration) => void\n}\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href)\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config)\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          )\n        })\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config)\n      }\n    })\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing\n        if (installingWorker == null) {\n          return\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              )\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration)\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.')\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration)\n              }\n            }\n          }\n        }\n      }\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error)\n    })\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type')\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload()\n          })\n        })\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config)\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      )\n    })\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then((registration) => {\n      registration.unregister()\n    })\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport Root from './Root'\nimport * as serviceWorker from './serviceWorkerRegistraction'\n\nReactDOM.render(<Root />, document.getElementById('root'))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}